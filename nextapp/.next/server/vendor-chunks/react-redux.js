"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-redux";
exports.ids = ["vendor-chunks/react-redux"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-redux/dist/cjs/index.js":
/*!****************************************************!*\
  !*** ./node_modules/react-redux/dist/cjs/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./react-redux.development.cjs */ \"(ssr)/./node_modules/react-redux/dist/cjs/react-redux.development.cjs\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsa0pBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZm9vZGllcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9kaXN0L2Nqcy9pbmRleC5qcz8zNGMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWN0LXJlZHV4LnByb2R1Y3Rpb24ubWluLmNqcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhY3QtcmVkdXguZGV2ZWxvcG1lbnQuY2pzJylcbn0iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-redux/dist/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-redux/dist/cjs/react-redux.development.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/react-redux/dist/cjs/react-redux.development.cjs ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    Provider: ()=>Provider_default,\n    ReactReduxContext: ()=>ReactReduxContext,\n    batch: ()=>batch,\n    connect: ()=>connect_default,\n    createDispatchHook: ()=>createDispatchHook,\n    createSelectorHook: ()=>createSelectorHook,\n    createStoreHook: ()=>createStoreHook,\n    shallowEqual: ()=>shallowEqual,\n    useDispatch: ()=>useDispatch,\n    useSelector: ()=>useSelector,\n    useStore: ()=>useStore\n});\nmodule.exports = __toCommonJS(src_exports);\nvar React2 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar import_with_selector = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/with-selector.js\");\n// src/utils/react.ts\nvar ReactOriginal = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar React = // prettier-ignore\n// @ts-ignore\n\"default\" in ReactOriginal ? ReactOriginal[\"default\"] : ReactOriginal;\n// src/components/Context.ts\nvar ContextKey = Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};\nfunction getContext() {\n    if (!React.createContext) return {};\n    const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());\n    let realContext = contextMap.get(React.createContext);\n    if (!realContext) {\n        realContext = React.createContext(null);\n        if (true) {\n            realContext.displayName = \"ReactRedux\";\n        }\n        contextMap.set(React.createContext, realContext);\n    }\n    return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n// src/utils/useSyncExternalStore.ts\nvar notInitialized = ()=>{\n    throw new Error(\"uSES not initialized!\");\n};\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook(context = ReactReduxContext) {\n    return function useReduxContext2() {\n        const contextValue = React.useContext(context);\n        if (!contextValue) {\n            throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n        }\n        return contextValue;\n    };\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n// src/hooks/useSelector.ts\nvar useSyncExternalStoreWithSelector = notInitialized;\nvar initializeUseSelector = (fn)=>{\n    useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = (a, b)=>a === b;\nfunction createSelectorHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n    const useSelector2 = (selector, equalityFnOrOptions = {})=>{\n        const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {\n            equalityFn: equalityFnOrOptions\n        } : equalityFnOrOptions;\n        if (true) {\n            if (!selector) {\n                throw new Error(`You must pass a selector to useSelector`);\n            }\n            if (typeof selector !== \"function\") {\n                throw new Error(`You must pass a function as a selector to useSelector`);\n            }\n            if (typeof equalityFn !== \"function\") {\n                throw new Error(`You must pass a function as an equality function to useSelector`);\n            }\n        }\n        const { store, subscription, getServerState, stabilityCheck, identityFunctionCheck } = useReduxContext2();\n        const firstRun = React.useRef(true);\n        const wrappedSelector = React.useCallback({\n            [selector.name] (state) {\n                const selected = selector(state);\n                if (true) {\n                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = {\n                        stabilityCheck,\n                        identityFunctionCheck,\n                        ...devModeChecks\n                    };\n                    if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n                        const toCompare = selector(state);\n                        if (!equalityFn(selected, toCompare)) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                                state,\n                                selected,\n                                selected2: toCompare,\n                                stack\n                            });\n                        }\n                    }\n                    if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n                        if (selected === state) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                                stack\n                            });\n                        }\n                    }\n                    if (firstRun.current) firstRun.current = false;\n                }\n                return selected;\n            }\n        }[selector.name], [\n            selector,\n            stabilityCheck,\n            devModeChecks.stabilityCheck\n        ]);\n        const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n        React.useDebugValue(selectedState);\n        return selectedState;\n    };\n    Object.assign(useSelector2, {\n        withTypes: ()=>useSelector2\n    });\n    return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n// src/utils/react-is.ts\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\nvar REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\nvar REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\nvar REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\nvar REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n    if (typeof type === \"string\" || typeof type === \"function\") {\n        return true;\n    }\n    if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n        return true;\n    }\n    if (typeof type === \"object\" && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction typeOf(object) {\n    if (typeof object === \"object\" && object !== null) {\n        const $$typeof = object.$$typeof;\n        switch($$typeof){\n            case REACT_ELEMENT_TYPE:\n                {\n                    const type = object.type;\n                    switch(type){\n                        case REACT_FRAGMENT_TYPE:\n                        case REACT_PROFILER_TYPE:\n                        case REACT_STRICT_MODE_TYPE:\n                        case REACT_SUSPENSE_TYPE:\n                        case REACT_SUSPENSE_LIST_TYPE:\n                            return type;\n                        default:\n                            {\n                                const $$typeofType = type && type.$$typeof;\n                                switch($$typeofType){\n                                    case REACT_SERVER_CONTEXT_TYPE:\n                                    case REACT_CONTEXT_TYPE:\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_LAZY_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                    case REACT_PROVIDER_TYPE:\n                                        return $$typeofType;\n                                    default:\n                                        return $$typeof;\n                                }\n                            }\n                    }\n                }\n            case REACT_PORTAL_TYPE:\n                {\n                    return $$typeof;\n                }\n        }\n    }\n    return void 0;\n}\nfunction isContextConsumer(object) {\n    return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n}\n// src/utils/warning.ts\nfunction warning(message) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    try {\n        throw new Error(message);\n    } catch (e) {}\n}\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n    if (!selector) {\n        throw new Error(`Unexpected value for ${methodName} in connect.`);\n    } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n        if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n            warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n        }\n    }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n    verify(mapStateToProps, \"mapStateToProps\");\n    verify(mapDispatchToProps, \"mapDispatchToProps\");\n    verify(mergeProps, \"mergeProps\");\n}\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }) {\n    let hasRunAtLeastOnce = false;\n    let state;\n    let ownProps;\n    let stateProps;\n    let dispatchProps;\n    let mergedProps;\n    function handleFirstCall(firstState, firstOwnProps) {\n        state = firstState;\n        ownProps = firstOwnProps;\n        stateProps = mapStateToProps(state, ownProps);\n        dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        hasRunAtLeastOnce = true;\n        return mergedProps;\n    }\n    function handleNewPropsAndNewState() {\n        stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewProps() {\n        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewState() {\n        const nextStateProps = mapStateToProps(state, ownProps);\n        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n        stateProps = nextStateProps;\n        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleSubsequentCalls(nextState, nextOwnProps) {\n        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n        state = nextState;\n        ownProps = nextOwnProps;\n        if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n        if (propsChanged) return handleNewProps();\n        if (stateChanged) return handleNewState();\n        return mergedProps;\n    }\n    return function pureFinalPropsSelector(nextState, nextOwnProps) {\n        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n    };\n}\nfunction finalPropsSelectorFactory(dispatch, { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }) {\n    const mapStateToProps = initMapStateToProps(dispatch, options);\n    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n    const mergeProps = initMergeProps(dispatch, options);\n    if (true) {\n        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n    }\n    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = (...args)=>dispatch(actionCreator(...args));\n        }\n    }\n    return boundActionCreators;\n}\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null) return true;\n    let baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n    if (!isPlainObject(value)) {\n        warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n    }\n}\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n    return function initConstantSelector(dispatch) {\n        const constant = getConstant(dispatch);\n        function constantSelector() {\n            return constant;\n        }\n        constantSelector.dependsOnOwnProps = false;\n        return constantSelector;\n    };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n    return function initProxySelector(dispatch, { displayName }) {\n        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n        };\n        proxy.dependsOnOwnProps = true;\n        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n            proxy.mapToProps = mapToProps;\n            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n            let props = proxy(stateOrDispatch, ownProps);\n            if (typeof props === \"function\") {\n                proxy.mapToProps = props;\n                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n                props = proxy(stateOrDispatch, ownProps);\n            }\n            if (true) verifyPlainObject(props, displayName, methodName);\n            return props;\n        };\n        return proxy;\n    };\n}\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n    return (dispatch, options)=>{\n        throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n    };\n}\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n    return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({\n            dispatch\n        })) : typeof mapDispatchToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n    return {\n        ...ownProps,\n        ...stateProps,\n        ...dispatchProps\n    };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n    return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {\n        let hasRunOnce = false;\n        let mergedProps;\n        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n            if (hasRunOnce) {\n                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n            } else {\n                hasRunOnce = true;\n                mergedProps = nextMergedProps;\n                if (true) verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n            }\n            return mergedProps;\n        };\n    };\n}\nfunction mergePropsFactory(mergeProps) {\n    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n    callback();\n}\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n    let first = null;\n    let last = null;\n    return {\n        clear () {\n            first = null;\n            last = null;\n        },\n        notify () {\n            defaultNoopBatch(()=>{\n                let listener = first;\n                while(listener){\n                    listener.callback();\n                    listener = listener.next;\n                }\n            });\n        },\n        get () {\n            const listeners = [];\n            let listener = first;\n            while(listener){\n                listeners.push(listener);\n                listener = listener.next;\n            }\n            return listeners;\n        },\n        subscribe (callback) {\n            let isSubscribed = true;\n            const listener = last = {\n                callback,\n                next: null,\n                prev: last\n            };\n            if (listener.prev) {\n                listener.prev.next = listener;\n            } else {\n                first = listener;\n            }\n            return function unsubscribe() {\n                if (!isSubscribed || first === null) return;\n                isSubscribed = false;\n                if (listener.next) {\n                    listener.next.prev = listener.prev;\n                } else {\n                    last = listener.prev;\n                }\n                if (listener.prev) {\n                    listener.prev.next = listener.next;\n                } else {\n                    first = listener.next;\n                }\n            };\n        }\n    };\n}\nvar nullListeners = {\n    notify () {},\n    get: ()=>[]\n};\nfunction createSubscription(store, parentSub) {\n    let unsubscribe;\n    let listeners = nullListeners;\n    let subscriptionsAmount = 0;\n    let selfSubscribed = false;\n    function addNestedSub(listener) {\n        trySubscribe();\n        const cleanupListener = listeners.subscribe(listener);\n        let removed = false;\n        return ()=>{\n            if (!removed) {\n                removed = true;\n                cleanupListener();\n                tryUnsubscribe();\n            }\n        };\n    }\n    function notifyNestedSubs() {\n        listeners.notify();\n    }\n    function handleChangeWrapper() {\n        if (subscription.onStateChange) {\n            subscription.onStateChange();\n        }\n    }\n    function isSubscribed() {\n        return selfSubscribed;\n    }\n    function trySubscribe() {\n        subscriptionsAmount++;\n        if (!unsubscribe) {\n            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n            listeners = createListenerCollection();\n        }\n    }\n    function tryUnsubscribe() {\n        subscriptionsAmount--;\n        if (unsubscribe && subscriptionsAmount === 0) {\n            unsubscribe();\n            unsubscribe = void 0;\n            listeners.clear();\n            listeners = nullListeners;\n        }\n    }\n    function trySubscribeSelf() {\n        if (!selfSubscribed) {\n            selfSubscribed = true;\n            trySubscribe();\n        }\n    }\n    function tryUnsubscribeSelf() {\n        if (selfSubscribed) {\n            selfSubscribed = false;\n            tryUnsubscribe();\n        }\n    }\n    const subscription = {\n        addNestedSub,\n        notifyNestedSubs,\n        handleChangeWrapper,\n        isSubscribed,\n        trySubscribe: trySubscribeSelf,\n        tryUnsubscribe: tryUnsubscribeSelf,\n        getListeners: ()=>listeners\n    };\n    return subscription;\n}\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = !!( false && 0);\nvar isReactNative = typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar useIsomorphicLayoutEffect = canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect;\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction shallowEqual(objA, objB) {\n    if (is(objA, objB)) return true;\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n    for(let i = 0; i < keysA.length; i++){\n        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar FORWARD_REF_STATICS = {\n    $$typeof: true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n};\nvar MEMO_STATICS = {\n    $$typeof: true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n};\nvar TYPE_STATICS = {\n    [ForwardRef]: FORWARD_REF_STATICS,\n    [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n    if (isMemo(component)) {\n        return MEMO_STATICS;\n    }\n    return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n    if (typeof sourceComponent !== \"string\") {\n        if (objectPrototype) {\n            const inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent);\n            }\n        }\n        let keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        const targetStatics = getStatics(targetComponent);\n        const sourceStatics = getStatics(sourceComponent);\n        for(let i = 0; i < keys.length; ++i){\n            const key = keys[i];\n            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n    }\n    return targetComponent;\n}\n// src/components/connect.tsx\nvar useSyncExternalStore = notInitialized;\nvar initializeConnect = (fn)=>{\n    useSyncExternalStore = fn;\n};\nvar NO_SUBSCRIPTION_ARRAY = [\n    null,\n    null\n];\nvar stringifyComponent = (Comp)=>{\n    try {\n        return JSON.stringify(Comp);\n    } catch (err) {\n        return String(Comp);\n    }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n    useIsomorphicLayoutEffect(()=>effectFunc(...effectArgs), dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n    lastWrapperProps.current = wrapperProps;\n    renderIsScheduled.current = false;\n    if (childPropsFromStoreUpdate.current) {\n        childPropsFromStoreUpdate.current = null;\n        notifyNestedSubs();\n    }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n    if (!shouldHandleStateChanges) return ()=>{};\n    let didUnsubscribe = false;\n    let lastThrownError = null;\n    const checkForUpdates = ()=>{\n        if (didUnsubscribe || !isMounted.current) {\n            return;\n        }\n        const latestStoreState = store.getState();\n        let newChildProps, error;\n        try {\n            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n        } catch (e) {\n            error = e;\n            lastThrownError = e;\n        }\n        if (!error) {\n            lastThrownError = null;\n        }\n        if (newChildProps === lastChildProps.current) {\n            if (!renderIsScheduled.current) {\n                notifyNestedSubs();\n            }\n        } else {\n            lastChildProps.current = newChildProps;\n            childPropsFromStoreUpdate.current = newChildProps;\n            renderIsScheduled.current = true;\n            additionalSubscribeListener();\n        }\n    };\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    const unsubscribeWrapper = ()=>{\n        didUnsubscribe = true;\n        subscription.tryUnsubscribe();\n        subscription.onStateChange = null;\n        if (lastThrownError) {\n            throw lastThrownError;\n        }\n    };\n    return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n    return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n// @ts-ignore\npure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component\nforwardRef = false, // the context consumer to use\ncontext = ReactReduxContext } = {}) {\n    if (true) {\n        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n            hasWarnedAboutDeprecatedPureOption = true;\n            warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n        }\n    }\n    const Context = context;\n    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n    const initMergeProps = mergePropsFactory(mergeProps);\n    const shouldHandleStateChanges = Boolean(mapStateToProps);\n    const wrapWithConnect = (WrappedComponent)=>{\n        if (true) {\n            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n            if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);\n        }\n        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n        const displayName = `Connect(${wrappedComponentName})`;\n        const selectorFactoryOptions = {\n            shouldHandleStateChanges,\n            displayName,\n            wrappedComponentName,\n            WrappedComponent,\n            // @ts-ignore\n            initMapStateToProps,\n            // @ts-ignore\n            initMapDispatchToProps,\n            initMergeProps,\n            areStatesEqual,\n            areStatePropsEqual,\n            areOwnPropsEqual,\n            areMergedPropsEqual\n        };\n        function ConnectFunction(props) {\n            const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(()=>{\n                const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n                return [\n                    props.context,\n                    reactReduxForwardedRef2,\n                    wrapperProps2\n                ];\n            }, [\n                props\n            ]);\n            const ContextToUse = React.useMemo(()=>{\n                let ResultContext = Context;\n                if (propsContext?.Consumer) {\n                    if (true) {\n                        const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore\n                        /* @__PURE__ */ React.createElement(propsContext.Consumer, null));\n                        if (!isValid) {\n                            throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n                        }\n                        ResultContext = propsContext;\n                    }\n                }\n                return ResultContext;\n            }, [\n                propsContext,\n                Context\n            ]);\n            const contextValue = React.useContext(ContextToUse);\n            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n            if (!didStoreComeFromProps && !didStoreComeFromContext) {\n                throw new Error(`Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);\n            }\n            const store = didStoreComeFromProps ? props.store : contextValue.store;\n            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n            const childPropsSelector = React.useMemo(()=>{\n                return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n            }, [\n                store\n            ]);\n            const [subscription, notifyNestedSubs] = React.useMemo(()=>{\n                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n                const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n                const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n                return [\n                    subscription2,\n                    notifyNestedSubs2\n                ];\n            }, [\n                store,\n                didStoreComeFromProps,\n                contextValue\n            ]);\n            const overriddenContextValue = React.useMemo(()=>{\n                if (didStoreComeFromProps) {\n                    return contextValue;\n                }\n                return {\n                    ...contextValue,\n                    subscription\n                };\n            }, [\n                didStoreComeFromProps,\n                contextValue,\n                subscription\n            ]);\n            const lastChildProps = React.useRef(void 0);\n            const lastWrapperProps = React.useRef(wrapperProps);\n            const childPropsFromStoreUpdate = React.useRef(void 0);\n            const renderIsScheduled = React.useRef(false);\n            const isMounted = React.useRef(false);\n            const latestSubscriptionCallbackError = React.useRef(void 0);\n            useIsomorphicLayoutEffect(()=>{\n                isMounted.current = true;\n                return ()=>{\n                    isMounted.current = false;\n                };\n            }, []);\n            const actualChildPropsSelector = React.useMemo(()=>{\n                const selector = ()=>{\n                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n                        return childPropsFromStoreUpdate.current;\n                    }\n                    return childPropsSelector(store.getState(), wrapperProps);\n                };\n                return selector;\n            }, [\n                store,\n                wrapperProps\n            ]);\n            const subscribeForReact = React.useMemo(()=>{\n                const subscribe = (reactListener)=>{\n                    if (!subscription) {\n                        return ()=>{};\n                    }\n                    return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n                    childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n                };\n                return subscribe;\n            }, [\n                subscription\n            ]);\n            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n                lastWrapperProps,\n                lastChildProps,\n                renderIsScheduled,\n                wrapperProps,\n                childPropsFromStoreUpdate,\n                notifyNestedSubs\n            ]);\n            let actualChildProps;\n            try {\n                actualChildProps = useSyncExternalStore(// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n                actualChildPropsSelector, getServerState ? ()=>childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n            } catch (err) {\n                if (latestSubscriptionCallbackError.current) {\n                    ;\n                    err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n                }\n                throw err;\n            }\n            useIsomorphicLayoutEffect(()=>{\n                latestSubscriptionCallbackError.current = void 0;\n                childPropsFromStoreUpdate.current = void 0;\n                lastChildProps.current = actualChildProps;\n            });\n            const renderedWrappedComponent = React.useMemo(()=>{\n                return(// @ts-ignore\n                /* @__PURE__ */ React.createElement(WrappedComponent, {\n                    ...actualChildProps,\n                    ref: reactReduxForwardedRef\n                }));\n            }, [\n                reactReduxForwardedRef,\n                WrappedComponent,\n                actualChildProps\n            ]);\n            const renderedChild = React.useMemo(()=>{\n                if (shouldHandleStateChanges) {\n                    return /* @__PURE__ */ React.createElement(ContextToUse.Provider, {\n                        value: overriddenContextValue\n                    }, renderedWrappedComponent);\n                }\n                return renderedWrappedComponent;\n            }, [\n                ContextToUse,\n                renderedWrappedComponent,\n                overriddenContextValue\n            ]);\n            return renderedChild;\n        }\n        const _Connect = React.memo(ConnectFunction);\n        const Connect = _Connect;\n        Connect.WrappedComponent = WrappedComponent;\n        Connect.displayName = ConnectFunction.displayName = displayName;\n        if (forwardRef) {\n            const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n                return /* @__PURE__ */ React.createElement(Connect, {\n                    ...props,\n                    reactReduxForwardedRef: ref\n                });\n            });\n            const forwarded = _forwarded;\n            forwarded.displayName = displayName;\n            forwarded.WrappedComponent = WrappedComponent;\n            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n        }\n        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n    };\n    return wrapWithConnect;\n}\nvar connect_default = connect;\n// src/components/Provider.tsx\nfunction Provider({ store, context, children, serverState, stabilityCheck = \"once\", identityFunctionCheck = \"once\" }) {\n    const contextValue = React.useMemo(()=>{\n        const subscription = createSubscription(store);\n        return {\n            store,\n            subscription,\n            getServerState: serverState ? ()=>serverState : void 0,\n            stabilityCheck,\n            identityFunctionCheck\n        };\n    }, [\n        store,\n        serverState,\n        stabilityCheck,\n        identityFunctionCheck\n    ]);\n    const previousState = React.useMemo(()=>store.getState(), [\n        store\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        const { subscription } = contextValue;\n        subscription.onStateChange = subscription.notifyNestedSubs;\n        subscription.trySubscribe();\n        if (previousState !== store.getState()) {\n            subscription.notifyNestedSubs();\n        }\n        return ()=>{\n            subscription.tryUnsubscribe();\n            subscription.onStateChange = void 0;\n        };\n    }, [\n        contextValue,\n        previousState\n    ]);\n    const Context = context || ReactReduxContext;\n    return /* @__PURE__ */ React.createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\nvar Provider_default = Provider;\n// src/hooks/useStore.ts\nfunction createStoreHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore\n    createReduxContextHook(context);\n    const useStore2 = ()=>{\n        const { store } = useReduxContext2();\n        return store;\n    };\n    Object.assign(useStore2, {\n        withTypes: ()=>useStore2\n    });\n    return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n// src/hooks/useDispatch.ts\nfunction createDispatchHook(context = ReactReduxContext) {\n    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n    const useDispatch2 = ()=>{\n        const store = useStore2();\n        return store.dispatch;\n    };\n    Object.assign(useDispatch2, {\n        withTypes: ()=>useDispatch2\n    });\n    return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n// src/exports.ts\nvar batch = defaultNoopBatch;\n// src/index.ts\ninitializeUseSelector(import_with_selector.useSyncExternalStoreWithSelector);\ninitializeConnect(React2.useSyncExternalStore);\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0); //# sourceMappingURL=react-redux.development.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9janMvcmVhY3QtcmVkdXguZGV2ZWxvcG1lbnQuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsV0FBV0MsT0FBT0MsTUFBTTtBQUM1QixJQUFJQyxZQUFZRixPQUFPRyxjQUFjO0FBQ3JDLElBQUlDLG1CQUFtQkosT0FBT0ssd0JBQXdCO0FBQ3RELElBQUlDLG9CQUFvQk4sT0FBT08sbUJBQW1CO0FBQ2xELElBQUlDLGVBQWVSLE9BQU9TLGNBQWM7QUFDeEMsSUFBSUMsZUFBZVYsT0FBT1csU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmYixVQUFVWSxRQUFRRSxNQUFNO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUFFRSxZQUFZO0lBQUs7QUFDL0Q7QUFDQSxJQUFJQyxjQUFjLENBQUNDLElBQUlDLE1BQU1DLFFBQVFDO0lBQ25DLElBQUlGLFFBQVEsT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWTtRQUNsRSxLQUFLLElBQUlHLE9BQU9sQixrQkFBa0JlLE1BQ2hDLElBQUksQ0FBQ1gsYUFBYWUsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q3BCLFVBQVVrQixJQUFJSSxLQUFLO1lBQUVQLEtBQUssSUFBTUksSUFBSSxDQUFDRyxJQUFJO1lBQUVOLFlBQVksQ0FBRUssQ0FBQUEsT0FBT25CLGlCQUFpQmlCLE1BQU1HLElBQUcsS0FBTUQsS0FBS0wsVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLElBQUlNLFVBQVUsQ0FBQ0MsS0FBS0MsWUFBWWQsU0FBWUEsQ0FBQUEsU0FBU2EsT0FBTyxPQUFPNUIsU0FBU1MsYUFBYW1CLFFBQVEsQ0FBQyxHQUFHUixZQUNuRyxzRUFBc0U7SUFDdEUsaUVBQWlFO0lBQ2pFLHNFQUFzRTtJQUN0RSxxRUFBcUU7SUFD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O1FBQ3ZCalEsV0FBVyxJQUFNaVE7SUFDbkI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSWpVLFdBQVcsYUFBYSxHQUFHSjtBQUUvQiwyQkFBMkI7QUFDM0IsU0FBU0YsbUJBQW1CNkIsVUFBVWpDLGlCQUFpQjtJQUNyRCxNQUFNMlUsWUFBWTFTLFlBQVlqQyxvQkFBb0JVLFdBQVdKLGdCQUFnQjJCO0lBQzdFLE1BQU0yUyxlQUFlO1FBQ25CLE1BQU0zUixRQUFRMFI7UUFDZCxPQUFPMVIsTUFBTThELFFBQVE7SUFDdkI7SUFDQWxKLE9BQU80RyxNQUFNLENBQUNtUSxjQUFjO1FBQzFCbFEsV0FBVyxJQUFNa1E7SUFDbkI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSXBVLGNBQWMsYUFBYSxHQUFHSjtBQUVsQyxpQkFBaUI7QUFDakIsSUFBSUgsUUFBUWtMO0FBRVosZUFBZTtBQUNmNUksc0JBQXNCeEIscUJBQXFCdUIsZ0NBQWdDO0FBQzNFK04sa0JBQWtCeFAsT0FBT3VQLG9CQUFvQjtBQUM3Qyw2REFBNkQ7QUFDN0QsS0FBTXpQLENBQUFBLENBWU4sR0FDQSxvREFBb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mb29kaWVzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2Rpc3QvY2pzL3JlYWN0LXJlZHV4LmRldmVsb3BtZW50LmNqcz8zYjg2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIFByb3ZpZGVyOiAoKSA9PiBQcm92aWRlcl9kZWZhdWx0LFxuICBSZWFjdFJlZHV4Q29udGV4dDogKCkgPT4gUmVhY3RSZWR1eENvbnRleHQsXG4gIGJhdGNoOiAoKSA9PiBiYXRjaCxcbiAgY29ubmVjdDogKCkgPT4gY29ubmVjdF9kZWZhdWx0LFxuICBjcmVhdGVEaXNwYXRjaEhvb2s6ICgpID0+IGNyZWF0ZURpc3BhdGNoSG9vayxcbiAgY3JlYXRlU2VsZWN0b3JIb29rOiAoKSA9PiBjcmVhdGVTZWxlY3Rvckhvb2ssXG4gIGNyZWF0ZVN0b3JlSG9vazogKCkgPT4gY3JlYXRlU3RvcmVIb29rLFxuICBzaGFsbG93RXF1YWw6ICgpID0+IHNoYWxsb3dFcXVhbCxcbiAgdXNlRGlzcGF0Y2g6ICgpID0+IHVzZURpc3BhdGNoLFxuICB1c2VTZWxlY3RvcjogKCkgPT4gdXNlU2VsZWN0b3IsXG4gIHVzZVN0b3JlOiAoKSA9PiB1c2VTdG9yZVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG52YXIgUmVhY3QyID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGltcG9ydF93aXRoX3NlbGVjdG9yID0gcmVxdWlyZShcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3dpdGgtc2VsZWN0b3IuanNcIik7XG5cbi8vIHNyYy91dGlscy9yZWFjdC50c1xudmFyIFJlYWN0T3JpZ2luYWwgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgUmVhY3QgPSAoXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICAvLyBAdHMtaWdub3JlXG4gIFwiZGVmYXVsdFwiIGluIFJlYWN0T3JpZ2luYWwgPyBSZWFjdE9yaWdpbmFsW1wiZGVmYXVsdFwiXSA6IFJlYWN0T3JpZ2luYWxcbik7XG5cbi8vIHNyYy9jb21wb25lbnRzL0NvbnRleHQudHNcbnZhciBDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihgcmVhY3QtcmVkdXgtY29udGV4dGApO1xudmFyIGdUID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogKFxuICAvKiBmYWxsIGJhY2sgdG8gYSBwZXItbW9kdWxlIHNjb3BlIChwcmUtOC4xIGJlaGF2aW91cikgaWYgYGdsb2JhbFRoaXNgIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAge31cbik7XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIVJlYWN0LmNyZWF0ZUNvbnRleHQpXG4gICAgcmV0dXJuIHt9O1xuICBjb25zdCBjb250ZXh0TWFwID0gZ1RbQ29udGV4dEtleV0gPz8gKGdUW0NvbnRleHRLZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGxldCByZWFsQ29udGV4dCA9IGNvbnRleHRNYXAuZ2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQpO1xuICBpZiAoIXJlYWxDb250ZXh0KSB7XG4gICAgcmVhbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIHJlYWxDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSZWFjdFJlZHV4XCI7XG4gICAgfVxuICAgIGNvbnRleHRNYXAuc2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQsIHJlYWxDb250ZXh0KTtcbiAgfVxuICByZXR1cm4gcmVhbENvbnRleHQ7XG59XG52YXIgUmVhY3RSZWR1eENvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gZ2V0Q29udGV4dCgpO1xuXG4vLyBzcmMvdXRpbHMvdXNlU3luY0V4dGVybmFsU3RvcmUudHNcbnZhciBub3RJbml0aWFsaXplZCA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwidVNFUyBub3QgaW5pdGlhbGl6ZWQhXCIpO1xufTtcblxuLy8gc3JjL2hvb2tzL3VzZVJlZHV4Q29udGV4dC50c1xuZnVuY3Rpb24gY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZVJlZHV4Q29udGV4dDIoKSB7XG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHRWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImNvdWxkIG5vdCBmaW5kIHJlYWN0LXJlZHV4IGNvbnRleHQgdmFsdWU7IHBsZWFzZSBlbnN1cmUgdGhlIGNvbXBvbmVudCBpcyB3cmFwcGVkIGluIGEgPFByb3ZpZGVyPlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICB9O1xufVxudmFyIHVzZVJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVSZWR1eENvbnRleHRIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VTZWxlY3Rvci50c1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZVVzZVNlbGVjdG9yID0gKGZuKSA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gZm47XG59O1xudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rvckhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZVNlbGVjdG9yMiA9IChzZWxlY3RvciwgZXF1YWxpdHlGbk9yT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHksIGRldk1vZGVDaGVja3MgPSB7fSB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHsgZXF1YWxpdHlGbjogZXF1YWxpdHlGbk9yT3B0aW9ucyB9IDogZXF1YWxpdHlGbk9yT3B0aW9ucztcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZXF1YWxpdHlGbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGFuIGVxdWFsaXR5IGZ1bmN0aW9uIHRvIHVzZVNlbGVjdG9yYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlLFxuICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9ID0gdXNlUmVkdXhDb250ZXh0MigpO1xuICAgIGNvbnN0IGZpcnN0UnVuID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAge1xuICAgICAgICBbc2VsZWN0b3IubmFtZV0oc3RhdGUpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgICAgICAgICAgICBzdGFiaWxpdHlDaGVjazogZmluYWxTdGFiaWxpdHlDaGVja1xuICAgICAgICAgICAgfSA9IHtcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgLi4uZGV2TW9kZUNoZWNrc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9Db21wYXJlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm4oc2VsZWN0ZWQsIHRvQ29tcGFyZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiBhIG5ldyByZWZlcmVuY2UgKHN1Y2ggYXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5KSBzaG91bGQgYmUgbWVtb2l6ZWQ6IGh0dHBzOi8vcmVkdXguanMub3JnL3VzYWdlL2Rlcml2aW5nLWRhdGEtc2VsZWN0b3JzI29wdGltaXppbmctc2VsZWN0b3JzLXdpdGgtbWVtb2l6YXRpb25cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDI6IHRvQ29tcGFyZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIlNlbGVjdG9yIFwiICsgKHNlbGVjdG9yLm5hbWUgfHwgXCJ1bmtub3duXCIpICsgXCIgcmV0dXJuZWQgdGhlIHJvb3Qgc3RhdGUgd2hlbiBjYWxsZWQuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiB0aGUgZW50aXJlIHN0YXRlIGFyZSBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSwgYXMgdGhleSB3aWxsIGNhdXNlIGEgcmVyZW5kZXIgd2hlbmV2ZXIgKmFueXRoaW5nKiBpbiBzdGF0ZSBjaGFuZ2VzLlwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGFjayB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0UnVuLmN1cnJlbnQpXG4gICAgICAgICAgICAgIGZpcnN0UnVuLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9W3NlbGVjdG9yLm5hbWVdLFxuICAgICAgW3NlbGVjdG9yLCBzdGFiaWxpdHlDaGVjaywgZGV2TW9kZUNoZWNrcy5zdGFiaWxpdHlDaGVja11cbiAgICApO1xuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmlwdGlvbi5hZGROZXN0ZWRTdWIsXG4gICAgICBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgZXF1YWxpdHlGblxuICAgICk7XG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTZWxlY3RvcjIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIHVzZVNlbGVjdG9yMjtcbn1cbnZhciB1c2VTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3Rvckhvb2soKTtcblxuLy8gc3JjL3V0aWxzL3JlYWN0LWlzLnRzXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIik7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXJfY29udGV4dFwiKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRToge1xuICAgICAgICBjb25zdCB0eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOiB7XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5cbi8vIHNyYy91dGlscy93YXJuaW5nLnRzXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLy8gc3JjL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLnRzXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3IsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBmb3IgJHttZXRob2ROYW1lfSBpbiBjb25uZWN0LmApO1xuICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09IFwibWFwU3RhdGVUb1Byb3BzXCIgfHwgbWV0aG9kTmFtZSA9PT0gXCJtYXBEaXNwYXRjaFRvUHJvcHNcIikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCBcImRlcGVuZHNPbk93blByb3BzXCIpKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBgVGhlIHNlbGVjdG9yIGZvciAke21ldGhvZE5hbWV9IG9mIGNvbm5lY3QgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkudHNcbmZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwge1xuICBhcmVTdGF0ZXNFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsXG59KSB7XG4gIGxldCBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICBsZXQgc3RhdGU7XG4gIGxldCBvd25Qcm9wcztcbiAgbGV0IHN0YXRlUHJvcHM7XG4gIGxldCBkaXNwYXRjaFByb3BzO1xuICBsZXQgbWVyZ2VkUHJvcHM7XG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzKCkge1xuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XG4gICAgc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZClcbiAgICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChcbiAgICAgIG5leHRTdGF0ZSxcbiAgICAgIHN0YXRlLFxuICAgICAgbmV4dE93blByb3BzLFxuICAgICAgb3duUHJvcHNcbiAgICApO1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKTtcbiAgICBpZiAocHJvcHNDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZSA/IGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgOiBoYW5kbGVGaXJzdENhbGwobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwge1xuICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICBpbml0TWVyZ2VQcm9wcyxcbiAgLi4ub3B0aW9uc1xufSkge1xuICBjb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1lcmdlUHJvcHMgPSBpbml0TWVyZ2VQcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGlmICh0cnVlKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKTtcbiAgfVxuICByZXR1cm4gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycy50c1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBjb25zdCBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9ICguLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cbi8vIHNyYy91dGlscy9pc1BsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGxldCBiYXNlUHJvdG8gPSBwcm90bztcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XG4gICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90byk7XG4gIH1cbiAgcmV0dXJuIHByb3RvID09PSBiYXNlUHJvdG87XG59XG5cbi8vIHNyYy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgYCR7bWV0aG9kTmFtZX0oKSBpbiAke2Rpc3BsYXlOYW1lfSBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3ZhbHVlfS5gXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy50c1xuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoKTtcbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufVxuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lIH0pIHtcbiAgICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIHZvaWQgMCk7XG4gICAgfTtcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgbGV0IHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cnVlKVxuICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChwcm9wcywgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xufVxuXG4vLyBzcmMvY29ubmVjdC9pbnZhbGlkQXJnRmFjdG9yeS50c1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkoYXJnLCBuYW1lKSB7XG4gIHJldHVybiAoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGFyZ30gZm9yICR7bmFtZX0gYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCAke29wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWV9LmBcbiAgICApO1xuICB9O1xufVxuXG4vLyBzcmMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMudHNcbmZ1bmN0aW9uIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBEaXNwYXRjaFRvUHJvcHMgJiYgdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gXCJvYmplY3RcIiA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoXG4gICAgKGRpc3BhdGNoKSA9PiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBiaW5kQWN0aW9uQ3JlYXRvcnMobWFwRGlzcGF0Y2hUb1Byb3BzLCBkaXNwYXRjaClcbiAgICApXG4gICkgOiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoZGlzcGF0Y2gpID0+ICh7XG4gICAgZGlzcGF0Y2hcbiAgfSkpIDogdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKVxuICApIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLnRzXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcFN0YXRlVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKCkgPT4gKHt9KSkgOiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpXG4gICkgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9tZXJnZVByb3BzLnRzXG5mdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICByZXR1cm4geyAuLi5vd25Qcm9wcywgLi4uc3RhdGVQcm9wcywgLi4uZGlzcGF0Y2hQcm9wcyB9O1xufVxuZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUsIGFyZU1lcmdlZFByb3BzRXF1YWwgfSkge1xuICAgIGxldCBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgbGV0IG1lcmdlZFByb3BzO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICAgIGNvbnN0IG5leHRNZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgICAgaWYgKGhhc1J1bk9uY2UpIHtcbiAgICAgICAgaWYgKCFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKVxuICAgICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWU7XG4gICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgICBpZiAodHJ1ZSlcbiAgICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsIFwibWVyZ2VQcm9wc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyAoKSA9PiBkZWZhdWx0TWVyZ2VQcm9wcyA6IHR5cGVvZiBtZXJnZVByb3BzID09PSBcImZ1bmN0aW9uXCIgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy91dGlscy9iYXRjaC50c1xuZnVuY3Rpb24gZGVmYXVsdE5vb3BCYXRjaChjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuXG4vLyBzcmMvdXRpbHMvU3Vic2NyaXB0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGxldCBmaXJzdCA9IG51bGw7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgIGxhc3QgPSBudWxsO1xuICAgIH0sXG4gICAgbm90aWZ5KCkge1xuICAgICAgZGVmYXVsdE5vb3BCYXRjaCgoKSA9PiB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjaygpO1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9LFxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGxhc3QgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdCA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5KCkge1xuICB9LFxuICBnZXQ6ICgpID0+IFtdXG59O1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIpIHtcbiAgbGV0IHVuc3Vic2NyaWJlO1xuICBsZXQgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgbGV0IHN1YnNjcmlwdGlvbnNBbW91bnQgPSAwO1xuICBsZXQgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgY29uc3QgY2xlYW51cExpc3RlbmVyID0gbGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZW1vdmVkKSB7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXIoKTtcbiAgICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgbGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVdyYXBwZXIoKSB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHNlbGZTdWJzY3JpYmVkO1xuICB9XG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50Kys7XG4gICAgaWYgKCF1bnN1YnNjcmliZSkge1xuICAgICAgdW5zdWJzY3JpYmUgPSBwYXJlbnRTdWIgPyBwYXJlbnRTdWIuYWRkTmVzdGVkU3ViKGhhbmRsZUNoYW5nZVdyYXBwZXIpIDogc3RvcmUuc3Vic2NyaWJlKGhhbmRsZUNoYW5nZVdyYXBwZXIpO1xuICAgICAgbGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQtLTtcbiAgICBpZiAodW5zdWJzY3JpYmUgJiYgc3Vic2NyaXB0aW9uc0Ftb3VudCA9PT0gMCkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIHVuc3Vic2NyaWJlID0gdm9pZCAwO1xuICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmICghc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKHNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgIGFkZE5lc3RlZFN1YixcbiAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgIGhhbmRsZUNoYW5nZVdyYXBwZXIsXG4gICAgaXNTdWJzY3JpYmVkLFxuICAgIHRyeVN1YnNjcmliZTogdHJ5U3Vic2NyaWJlU2VsZixcbiAgICB0cnlVbnN1YnNjcmliZTogdHJ5VW5zdWJzY3JpYmVTZWxmLFxuICAgIGdldExpc3RlbmVyczogKCkgPT4gbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBzdWJzY3JpcHRpb247XG59XG5cbi8vIHNyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LnRzXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIik7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gY2FuVXNlRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5cbi8vIHNyYy91dGlscy9zaGFsbG93RXF1YWwudHNcbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2hvaXN0U3RhdGljcy50c1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7XG4gIFtGb3J3YXJkUmVmXTogRk9SV0FSRF9SRUZfU1RBVElDUyxcbiAgW01lbW9dOiBNRU1PX1NUQVRJQ1Ncbn07XG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICBpZiAoaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9XG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50W1wiJCR0eXBlb2ZcIl1dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBjb25zdCBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgY29uc3Qgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9jb25uZWN0LnRzeFxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZUNvbm5lY3QgPSAoZm4pID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBmbjtcbn07XG52YXIgTk9fU1VCU0NSSVBUSU9OX0FSUkFZID0gW251bGwsIG51bGxdO1xudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IChDb21wKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCA9IHdyYXBwZXJQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlO1xuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbDtcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICBsZXQgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgbGV0IGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gIGNvbnN0IGNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgICBpZiAoZGlkVW5zdWJzY3JpYmUgfHwgIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhdGVzdFN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGxldCBuZXdDaGlsZFByb3BzLCBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgbmV3Q2hpbGRQcm9wcyA9IGNoaWxkUHJvcHNTZWxlY3RvcihcbiAgICAgICAgbGF0ZXN0U3RvcmVTdGF0ZSxcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IGU7XG4gICAgfVxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XG4gICAgICBpZiAoIXJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQpIHtcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpO1xuICAgIH1cbiAgfTtcbiAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBjaGVja0ZvclVwZGF0ZXM7XG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgY2hlY2tGb3JVcGRhdGVzKCk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlV3JhcHBlciA9ICgpID0+IHtcbiAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcbiAgICAgIHRocm93IGxhc3RUaHJvd25FcnJvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1bnN1YnNjcmliZVdyYXBwZXI7XG59XG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIHtcbiAgLy8gVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCwgc28gVFMgZG9lc24ndCBsaWtlIHVzIGRlc3RydWN0dXJpbmcgdGhpcyB0byBjaGVjayBpdHMgZXhpc3RlbmNlLlxuICAvLyBAdHMtaWdub3JlXG4gIHB1cmUsXG4gIGFyZVN0YXRlc0VxdWFsID0gc3RyaWN0RXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgLy8gdXNlIFJlYWN0J3MgZm9yd2FyZFJlZiB0byBleHBvc2UgYSByZWYgb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gIGZvcndhcmRSZWYgPSBmYWxzZSxcbiAgLy8gdGhlIGNvbnRleHQgY29uc3VtZXIgdG8gdXNlXG4gIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dFxufSA9IHt9KSB7XG4gIGlmICh0cnVlKSB7XG4gICAgaWYgKHB1cmUgIT09IHZvaWQgMCAmJiAhaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbikge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAnVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gYGNvbm5lY3RgIGlzIG5vdyBhbHdheXMgYSBcInB1cmUvbWVtb2l6ZWRcIiBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dDtcbiAgY29uc3QgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1lcmdlUHJvcHMgPSBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKTtcbiAgY29uc3Qgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCB3cmFwV2l0aENvbm5lY3QgPSAoV3JhcHBlZENvbXBvbmVudCkgPT4ge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzVmFsaWRFbGVtZW50VHlwZShXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgY29tcG9uZW50IHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBjb25uZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7c3RyaW5naWZ5Q29tcG9uZW50KFxuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudFxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBgQ29ubmVjdCgke3dyYXBwZWRDb21wb25lbnROYW1lfSlgO1xuICAgIGNvbnN0IHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMgPSB7XG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBkaXNwbGF5TmFtZSxcbiAgICAgIHdyYXBwZWRDb21wb25lbnROYW1lLFxuICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMsXG4gICAgICBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsXG4gICAgfTtcbiAgICBmdW5jdGlvbiBDb25uZWN0RnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIGNvbnN0IFtwcm9wc0NvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgLi4ud3JhcHBlclByb3BzMiB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiBbcHJvcHMuY29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIHdyYXBwZXJQcm9wczJdO1xuICAgICAgfSwgW3Byb3BzXSk7XG4gICAgICBjb25zdCBDb250ZXh0VG9Vc2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IFJlc3VsdENvbnRleHQgPSBDb250ZXh0O1xuICAgICAgICBpZiAocHJvcHNDb250ZXh0Py5Db25zdW1lcikge1xuICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzQ29udGV4dENvbnN1bWVyKFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgYXMgYHByb3BzLmNvbnRleHRgXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlc3VsdENvbnRleHQgPSBwcm9wc0NvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXN1bHRDb250ZXh0O1xuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pO1xuICAgICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0VG9Vc2UpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbVByb3BzID0gQm9vbGVhbihwcm9wcy5zdG9yZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5nZXRTdGF0ZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5kaXNwYXRjaCk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG4gICAgICBpZiAoIWRpZFN0b3JlQ29tZUZyb21Qcm9wcyAmJiAhZGlkU3RvcmVDb21lRnJvbUNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBcInN0b3JlXCIgaW4gdGhlIGNvbnRleHQgb2YgXCIke2Rpc3BsYXlOYW1lfVwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBvciBwYXNzIGEgY3VzdG9tIFJlYWN0IGNvbnRleHQgcHJvdmlkZXIgdG8gPFByb3ZpZGVyPiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgUmVhY3QgY29udGV4dCBjb25zdW1lciB0byAke2Rpc3BsYXlOYW1lfSBpbiBjb25uZWN0IG9wdGlvbnMuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmUgPSBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyBwcm9wcy5zdG9yZSA6IGNvbnRleHRWYWx1ZS5zdG9yZTtcbiAgICAgIGNvbnN0IGdldFNlcnZlclN0YXRlID0gZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPyBjb250ZXh0VmFsdWUuZ2V0U2VydmVyU3RhdGUgOiBzdG9yZS5nZXRTdGF0ZTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNTZWxlY3RvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShzdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyk7XG4gICAgICB9LCBbc3RvcmVdKTtcbiAgICAgIGNvbnN0IFtzdWJzY3JpcHRpb24sIG5vdGlmeU5lc3RlZFN1YnNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKVxuICAgICAgICAgIHJldHVybiBOT19TVUJTQ1JJUFRJT05fQVJSQVk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbjIgPSBjcmVhdGVTdWJzY3JpcHRpb24oXG4gICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgZGlkU3RvcmVDb21lRnJvbVByb3BzID8gdm9pZCAwIDogY29udGV4dFZhbHVlLnN1YnNjcmlwdGlvblxuICAgICAgICApO1xuICAgICAgICBjb25zdCBub3RpZnlOZXN0ZWRTdWJzMiA9IHN1YnNjcmlwdGlvbjIubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHN1YnNjcmlwdGlvbjIpO1xuICAgICAgICByZXR1cm4gW3N1YnNjcmlwdGlvbjIsIG5vdGlmeU5lc3RlZFN1YnMyXTtcbiAgICAgIH0sIFtzdG9yZSwgZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWVdKTtcbiAgICAgIGNvbnN0IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGRpZFN0b3JlQ29tZUZyb21Qcm9wcykge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jb250ZXh0VmFsdWUsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICB9LCBbZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWUsIHN1YnNjcmlwdGlvbl0pO1xuICAgICAgY29uc3QgbGFzdENoaWxkUHJvcHMgPSBSZWFjdC51c2VSZWYodm9pZCAwKTtcbiAgICAgIGNvbnN0IGxhc3RXcmFwcGVyUHJvcHMgPSBSZWFjdC51c2VSZWYod3JhcHBlclByb3BzKTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUgPSBSZWFjdC51c2VSZWYodm9pZCAwKTtcbiAgICAgIGNvbnN0IHJlbmRlcklzU2NoZWR1bGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gUmVhY3QudXNlUmVmKFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9LCBbXSk7XG4gICAgICBjb25zdCBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCAmJiB3cmFwcGVyUHJvcHMgPT09IGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNTZWxlY3RvcihzdG9yZS5nZXRTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9LCBbc3RvcmUsIHdyYXBwZXJQcm9wc10pO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlRm9yUmVhY3QgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gKHJlYWN0TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVVcGRhdGVzKFxuICAgICAgICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgICBsYXN0V3JhcHBlclByb3BzLFxuICAgICAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJJc1NjaGVkdWxlZCxcbiAgICAgICAgICAgIGlzTW91bnRlZCxcbiAgICAgICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgICAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgICAgICAgICAgcmVhY3RMaXN0ZW5lclxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmU7XG4gICAgICB9LCBbc3Vic2NyaXB0aW9uXSk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoY2FwdHVyZVdyYXBwZXJQcm9wcywgW1xuICAgICAgICBsYXN0V3JhcHBlclByb3BzLFxuICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcbiAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgIHdyYXBwZXJQcm9wcyxcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcbiAgICAgICAgbm90aWZ5TmVzdGVkU3Vic1xuICAgICAgXSk7XG4gICAgICBsZXQgYWN0dWFsQ2hpbGRQcm9wcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdHVhbENoaWxkUHJvcHMgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICAvLyBUT0RPIFdlJ3JlIHBhc3NpbmcgdGhyb3VnaCBhIGJpZyB3cmFwcGVyIHRoYXQgZG9lcyBhIGJ1bmNoIG9mIGV4dHJhIHNpZGUgZWZmZWN0cyBiZXNpZGVzIHN1YnNjcmliaW5nXG4gICAgICAgICAgc3Vic2NyaWJlRm9yUmVhY3QsXG4gICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIGluY3JlZGlibHkgaGFja3kuIFdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZSBzdG9yZSB1cGRhdGUgYW5kIGNhbGN1bGF0ZWQgbmV3IGNoaWxkIHByb3BzLFxuICAgICAgICAgIC8vIFRPRE8gYW5kIHdlJ3JlIGp1c3QgcGFzc2luZyB0aGF0IHRocm91Z2ggc28gaXQgdHJpZ2dlcnMgYSByZS1yZW5kZXIgZm9yIHVzIHJhdGhlciB0aGFuIHJlbHlpbmcgb24gYHVTRVNgLlxuICAgICAgICAgIGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvcixcbiAgICAgICAgICBnZXRTZXJ2ZXJTdGF0ZSA/ICgpID0+IGNoaWxkUHJvcHNTZWxlY3RvcihnZXRTZXJ2ZXJTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpIDogYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBlcnIubWVzc2FnZSArPSBgXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxuJHtsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2t9XG5cbmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gYWN0dWFsQ2hpbGRQcm9wcztcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uYWN0dWFsQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgICAgcmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0VG9Vc2UuUHJvdmlkZXIsIHsgdmFsdWU6IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgfSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgfSwgW0NvbnRleHRUb1VzZSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50LCBvdmVycmlkZGVuQ29udGV4dFZhbHVlXSk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDaGlsZDtcbiAgICB9XG4gICAgY29uc3QgX0Nvbm5lY3QgPSBSZWFjdC5tZW1vKENvbm5lY3RGdW5jdGlvbik7XG4gICAgY29uc3QgQ29ubmVjdCA9IF9Db25uZWN0O1xuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IENvbm5lY3RGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICBjb25zdCBfZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZENvbm5lY3RSZWYocHJvcHMsIHJlZikge1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0LCB7IC4uLnByb3BzLCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWYgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBmb3J3YXJkZWQgPSBfZm9yd2FyZGVkO1xuICAgICAgZm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICBmb3J3YXJkZWQuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKGZvcndhcmRlZCwgV3JhcHBlZENvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaG9pc3ROb25SZWFjdFN0YXRpY3MoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG4gIHJldHVybiB3cmFwV2l0aENvbm5lY3Q7XG59XG52YXIgY29ubmVjdF9kZWZhdWx0ID0gY29ubmVjdDtcblxuLy8gc3JjL2NvbXBvbmVudHMvUHJvdmlkZXIudHN4XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgc2VydmVyU3RhdGUsXG4gIHN0YWJpbGl0eUNoZWNrID0gXCJvbmNlXCIsXG4gIGlkZW50aXR5RnVuY3Rpb25DaGVjayA9IFwib25jZVwiXG59KSB7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGU6IHNlcnZlclN0YXRlID8gKCkgPT4gc2VydmVyU3RhdGUgOiB2b2lkIDAsXG4gICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgIH07XG4gIH0sIFtzdG9yZSwgc2VydmVyU3RhdGUsIHN0YWJpbGl0eUNoZWNrLCBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tdKTtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKSwgW3N0b3JlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gPSBjb250ZXh0VmFsdWU7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicztcbiAgICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHN0b3JlLmdldFN0YXRlKCkpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gdm9pZCAwO1xuICAgIH07XG4gIH0sIFtjb250ZXh0VmFsdWUsIHByZXZpb3VzU3RhdGVdKTtcbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQgfHwgUmVhY3RSZWR1eENvbnRleHQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSwgY2hpbGRyZW4pO1xufVxudmFyIFByb3ZpZGVyX2RlZmF1bHQgPSBQcm92aWRlcjtcblxuLy8gc3JjL2hvb2tzL3VzZVN0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KVxuICApO1xuICBjb25zdCB1c2VTdG9yZTIgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gdXNlUmVkdXhDb250ZXh0MigpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTdG9yZTIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVN0b3JlMlxuICB9KTtcbiAgcmV0dXJuIHVzZVN0b3JlMjtcbn1cbnZhciB1c2VTdG9yZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTdG9yZUhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZURpc3BhdGNoLnRzXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVN0b3JlMiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlU3RvcmUgOiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZURpc3BhdGNoMiA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlMigpO1xuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaDtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VEaXNwYXRjaDIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZURpc3BhdGNoMlxuICB9KTtcbiAgcmV0dXJuIHVzZURpc3BhdGNoMjtcbn1cbnZhciB1c2VEaXNwYXRjaCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEaXNwYXRjaEhvb2soKTtcblxuLy8gc3JjL2V4cG9ydHMudHNcbnZhciBiYXRjaCA9IGRlZmF1bHROb29wQmF0Y2g7XG5cbi8vIHNyYy9pbmRleC50c1xuaW5pdGlhbGl6ZVVzZVNlbGVjdG9yKGltcG9ydF93aXRoX3NlbGVjdG9yLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKTtcbmluaXRpYWxpemVDb25uZWN0KFJlYWN0Mi51c2VTeW5jRXh0ZXJuYWxTdG9yZSk7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUHJvdmlkZXIsXG4gIFJlYWN0UmVkdXhDb250ZXh0LFxuICBiYXRjaCxcbiAgY29ubmVjdCxcbiAgY3JlYXRlRGlzcGF0Y2hIb29rLFxuICBjcmVhdGVTZWxlY3Rvckhvb2ssXG4gIGNyZWF0ZVN0b3JlSG9vayxcbiAgc2hhbGxvd0VxdWFsLFxuICB1c2VEaXNwYXRjaCxcbiAgdXNlU2VsZWN0b3IsXG4gIHVzZVN0b3JlXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJlZHV4LmRldmVsb3BtZW50LmNqcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGUiLCJPYmplY3QiLCJjcmVhdGUiLCJfX2RlZlByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2dldFByb3RvT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJfX3RvRVNNIiwibW9kIiwiaXNOb2RlTW9kZSIsIl9fZXNNb2R1bGUiLCJ2YWx1ZSIsIl9fdG9Db21tb25KUyIsInNyY19leHBvcnRzIiwiUHJvdmlkZXIiLCJQcm92aWRlcl9kZWZhdWx0IiwiUmVhY3RSZWR1eENvbnRleHQiLCJiYXRjaCIsImNvbm5lY3QiLCJjb25uZWN0X2RlZmF1bHQiLCJjcmVhdGVEaXNwYXRjaEhvb2siLCJjcmVhdGVTZWxlY3Rvckhvb2siLCJjcmVhdGVTdG9yZUhvb2siLCJzaGFsbG93RXF1YWwiLCJ1c2VEaXNwYXRjaCIsInVzZVNlbGVjdG9yIiwidXNlU3RvcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiUmVhY3QyIiwicmVxdWlyZSIsImltcG9ydF93aXRoX3NlbGVjdG9yIiwiUmVhY3RPcmlnaW5hbCIsIlJlYWN0IiwiQ29udGV4dEtleSIsIlN5bWJvbCIsImZvciIsImdUIiwiZ2xvYmFsVGhpcyIsImdldENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiY29udGV4dE1hcCIsIk1hcCIsInJlYWxDb250ZXh0IiwiZGlzcGxheU5hbWUiLCJzZXQiLCJub3RJbml0aWFsaXplZCIsIkVycm9yIiwiY3JlYXRlUmVkdXhDb250ZXh0SG9vayIsImNvbnRleHQiLCJ1c2VSZWR1eENvbnRleHQyIiwiY29udGV4dFZhbHVlIiwidXNlQ29udGV4dCIsInVzZVJlZHV4Q29udGV4dCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwiaW5pdGlhbGl6ZVVzZVNlbGVjdG9yIiwiZm4iLCJyZWZFcXVhbGl0eSIsImEiLCJiIiwidXNlU2VsZWN0b3IyIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuT3JPcHRpb25zIiwiZXF1YWxpdHlGbiIsImRldk1vZGVDaGVja3MiLCJzdG9yZSIsInN1YnNjcmlwdGlvbiIsImdldFNlcnZlclN0YXRlIiwic3RhYmlsaXR5Q2hlY2siLCJpZGVudGl0eUZ1bmN0aW9uQ2hlY2siLCJmaXJzdFJ1biIsInVzZVJlZiIsIndyYXBwZWRTZWxlY3RvciIsInVzZUNhbGxiYWNrIiwic3RhdGUiLCJzZWxlY3RlZCIsImZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwiZmluYWxTdGFiaWxpdHlDaGVjayIsImN1cnJlbnQiLCJ0b0NvbXBhcmUiLCJzdGFjayIsImUiLCJjb25zb2xlIiwid2FybiIsInNlbGVjdGVkMiIsInNlbGVjdGVkU3RhdGUiLCJhZGROZXN0ZWRTdWIiLCJnZXRTdGF0ZSIsInVzZURlYnVnVmFsdWUiLCJhc3NpZ24iLCJ3aXRoVHlwZXMiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UiLCJGb3J3YXJkUmVmIiwiTWVtbyIsImlzVmFsaWRFbGVtZW50VHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsImdldE1vZHVsZUlkIiwidHlwZU9mIiwib2JqZWN0IiwiJCR0eXBlb2ZUeXBlIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJpc01lbW8iLCJ3YXJuaW5nIiwibWVzc2FnZSIsImVycm9yIiwidmVyaWZ5IiwibWV0aG9kTmFtZSIsInZlcmlmeVN1YnNlbGVjdG9ycyIsIm1hcFN0YXRlVG9Qcm9wcyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsIm1lcmdlUHJvcHMiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsImRpc3BhdGNoIiwiYXJlU3RhdGVzRXF1YWwiLCJhcmVPd25Qcm9wc0VxdWFsIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiaGFzUnVuQXRMZWFzdE9uY2UiLCJvd25Qcm9wcyIsInN0YXRlUHJvcHMiLCJkaXNwYXRjaFByb3BzIiwibWVyZ2VkUHJvcHMiLCJoYW5kbGVGaXJzdENhbGwiLCJmaXJzdFN0YXRlIiwiZmlyc3RPd25Qcm9wcyIsImhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUiLCJkZXBlbmRzT25Pd25Qcm9wcyIsImhhbmRsZU5ld1Byb3BzIiwiaGFuZGxlTmV3U3RhdGUiLCJuZXh0U3RhdGVQcm9wcyIsInN0YXRlUHJvcHNDaGFuZ2VkIiwiaGFuZGxlU3Vic2VxdWVudENhbGxzIiwibmV4dFN0YXRlIiwibmV4dE93blByb3BzIiwicHJvcHNDaGFuZ2VkIiwic3RhdGVDaGFuZ2VkIiwicHVyZUZpbmFsUHJvcHNTZWxlY3RvciIsImZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkiLCJpbml0TWFwU3RhdGVUb1Byb3BzIiwiaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyIsImluaXRNZXJnZVByb3BzIiwib3B0aW9ucyIsImJpbmRBY3Rpb25DcmVhdG9ycyIsImFjdGlvbkNyZWF0b3JzIiwiYm91bmRBY3Rpb25DcmVhdG9ycyIsImFjdGlvbkNyZWF0b3IiLCJhcmdzIiwiaXNQbGFpbk9iamVjdCIsIm9iaiIsInByb3RvIiwiYmFzZVByb3RvIiwidmVyaWZ5UGxhaW5PYmplY3QiLCJ3cmFwTWFwVG9Qcm9wc0NvbnN0YW50IiwiZ2V0Q29uc3RhbnQiLCJpbml0Q29uc3RhbnRTZWxlY3RvciIsImNvbnN0YW50IiwiY29uc3RhbnRTZWxlY3RvciIsImdldERlcGVuZHNPbk93blByb3BzIiwibWFwVG9Qcm9wcyIsIkJvb2xlYW4iLCJsZW5ndGgiLCJ3cmFwTWFwVG9Qcm9wc0Z1bmMiLCJpbml0UHJveHlTZWxlY3RvciIsInByb3h5IiwibWFwVG9Qcm9wc1Byb3h5Iiwic3RhdGVPckRpc3BhdGNoIiwiZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSIsInByb3BzIiwiY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkiLCJhcmciLCJ3cmFwcGVkQ29tcG9uZW50TmFtZSIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkiLCJtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IiwiZGVmYXVsdE1lcmdlUHJvcHMiLCJ3cmFwTWVyZ2VQcm9wc0Z1bmMiLCJpbml0TWVyZ2VQcm9wc1Byb3h5IiwiYXJlTWVyZ2VkUHJvcHNFcXVhbCIsImhhc1J1bk9uY2UiLCJtZXJnZVByb3BzUHJveHkiLCJuZXh0TWVyZ2VkUHJvcHMiLCJtZXJnZVByb3BzRmFjdG9yeSIsImRlZmF1bHROb29wQmF0Y2giLCJjYWxsYmFjayIsImNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbiIsImZpcnN0IiwibGFzdCIsImNsZWFyIiwibm90aWZ5IiwibGlzdGVuZXIiLCJuZXh0IiwibGlzdGVuZXJzIiwicHVzaCIsInN1YnNjcmliZSIsImlzU3Vic2NyaWJlZCIsInByZXYiLCJ1bnN1YnNjcmliZSIsIm51bGxMaXN0ZW5lcnMiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJwYXJlbnRTdWIiLCJzdWJzY3JpcHRpb25zQW1vdW50Iiwic2VsZlN1YnNjcmliZWQiLCJ0cnlTdWJzY3JpYmUiLCJjbGVhbnVwTGlzdGVuZXIiLCJyZW1vdmVkIiwidHJ5VW5zdWJzY3JpYmUiLCJub3RpZnlOZXN0ZWRTdWJzIiwiaGFuZGxlQ2hhbmdlV3JhcHBlciIsIm9uU3RhdGVDaGFuZ2UiLCJ0cnlTdWJzY3JpYmVTZWxmIiwidHJ5VW5zdWJzY3JpYmVTZWxmIiwiZ2V0TGlzdGVuZXJzIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNSZWFjdE5hdGl2ZSIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwiaXMiLCJ4IiwieSIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJpIiwiUkVBQ1RfU1RBVElDUyIsImNoaWxkQ29udGV4dFR5cGVzIiwiY29udGV4dFR5cGUiLCJjb250ZXh0VHlwZXMiLCJkZWZhdWx0UHJvcHMiLCJnZXREZWZhdWx0UHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJtaXhpbnMiLCJwcm9wVHlwZXMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJndW1lbnRzIiwiYXJpdHkiLCJGT1JXQVJEX1JFRl9TVEFUSUNTIiwicmVuZGVyIiwiTUVNT19TVEFUSUNTIiwiY29tcGFyZSIsIlRZUEVfU1RBVElDUyIsImdldFN0YXRpY3MiLCJjb21wb25lbnQiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvYmplY3RQcm90b3R5cGUiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsInRhcmdldENvbXBvbmVudCIsInNvdXJjZUNvbXBvbmVudCIsImluaGVyaXRlZENvbXBvbmVudCIsImNvbmNhdCIsInRhcmdldFN0YXRpY3MiLCJzb3VyY2VTdGF0aWNzIiwiZGVzY3JpcHRvciIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwiaW5pdGlhbGl6ZUNvbm5lY3QiLCJOT19TVUJTQ1JJUFRJT05fQVJSQVkiLCJzdHJpbmdpZnlDb21wb25lbnQiLCJDb21wIiwiSlNPTiIsInN0cmluZ2lmeSIsImVyciIsIlN0cmluZyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyIsImVmZmVjdEZ1bmMiLCJlZmZlY3RBcmdzIiwiZGVwZW5kZW5jaWVzIiwiY2FwdHVyZVdyYXBwZXJQcm9wcyIsImxhc3RXcmFwcGVyUHJvcHMiLCJsYXN0Q2hpbGRQcm9wcyIsInJlbmRlcklzU2NoZWR1bGVkIiwid3JhcHBlclByb3BzIiwiY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSIsInN1YnNjcmliZVVwZGF0ZXMiLCJzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMiLCJjaGlsZFByb3BzU2VsZWN0b3IiLCJpc01vdW50ZWQiLCJhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIiLCJkaWRVbnN1YnNjcmliZSIsImxhc3RUaHJvd25FcnJvciIsImNoZWNrRm9yVXBkYXRlcyIsImxhdGVzdFN0b3JlU3RhdGUiLCJuZXdDaGlsZFByb3BzIiwidW5zdWJzY3JpYmVXcmFwcGVyIiwic3RyaWN0RXF1YWwiLCJoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uIiwicHVyZSIsImZvcndhcmRSZWYiLCJDb250ZXh0Iiwid3JhcFdpdGhDb25uZWN0IiwiV3JhcHBlZENvbXBvbmVudCIsImlzVmFsaWQiLCJzZWxlY3RvckZhY3RvcnlPcHRpb25zIiwiQ29ubmVjdEZ1bmN0aW9uIiwicHJvcHNDb250ZXh0IiwicmVhY3RSZWR1eEZvcndhcmRlZFJlZiIsInVzZU1lbW8iLCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiIsIndyYXBwZXJQcm9wczIiLCJDb250ZXh0VG9Vc2UiLCJSZXN1bHRDb250ZXh0IiwiQ29uc3VtZXIiLCJkaWRTdG9yZUNvbWVGcm9tUHJvcHMiLCJkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCIsInN1YnNjcmlwdGlvbjIiLCJub3RpZnlOZXN0ZWRTdWJzMiIsImJpbmQiLCJvdmVycmlkZGVuQ29udGV4dFZhbHVlIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciIsInN1YnNjcmliZUZvclJlYWN0IiwicmVhY3RMaXN0ZW5lciIsImFjdHVhbENoaWxkUHJvcHMiLCJyZW5kZXJlZFdyYXBwZWRDb21wb25lbnQiLCJyZWYiLCJyZW5kZXJlZENoaWxkIiwiX0Nvbm5lY3QiLCJtZW1vIiwiQ29ubmVjdCIsIl9mb3J3YXJkZWQiLCJmb3J3YXJkQ29ubmVjdFJlZiIsImZvcndhcmRlZCIsImNoaWxkcmVuIiwic2VydmVyU3RhdGUiLCJwcmV2aW91c1N0YXRlIiwidXNlU3RvcmUyIiwidXNlRGlzcGF0Y2gyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-redux/dist/cjs/react-redux.development.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-redux/dist/react-redux.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/with-selector.js\");\n// src/index.ts\n\n\n// src/utils/react.ts\n\nvar React = // prettier-ignore\n// @ts-ignore\n true ? react__WEBPACK_IMPORTED_MODULE_0__ : /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)));\n// src/components/Context.ts\nvar ContextKey = Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};\nfunction getContext() {\n    if (!React.createContext) return {};\n    const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());\n    let realContext = contextMap.get(React.createContext);\n    if (!realContext) {\n        realContext = React.createContext(null);\n        if (true) {\n            realContext.displayName = \"ReactRedux\";\n        }\n        contextMap.set(React.createContext, realContext);\n    }\n    return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n// src/utils/useSyncExternalStore.ts\nvar notInitialized = ()=>{\n    throw new Error(\"uSES not initialized!\");\n};\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook(context = ReactReduxContext) {\n    return function useReduxContext2() {\n        const contextValue = React.useContext(context);\n        if ( true && !contextValue) {\n            throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n        }\n        return contextValue;\n    };\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n// src/hooks/useSelector.ts\nvar useSyncExternalStoreWithSelector = notInitialized;\nvar initializeUseSelector = (fn)=>{\n    useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = (a, b)=>a === b;\nfunction createSelectorHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n    const useSelector2 = (selector, equalityFnOrOptions = {})=>{\n        const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {\n            equalityFn: equalityFnOrOptions\n        } : equalityFnOrOptions;\n        if (true) {\n            if (!selector) {\n                throw new Error(`You must pass a selector to useSelector`);\n            }\n            if (typeof selector !== \"function\") {\n                throw new Error(`You must pass a function as a selector to useSelector`);\n            }\n            if (typeof equalityFn !== \"function\") {\n                throw new Error(`You must pass a function as an equality function to useSelector`);\n            }\n        }\n        const { store, subscription, getServerState, stabilityCheck, identityFunctionCheck } = useReduxContext2();\n        const firstRun = React.useRef(true);\n        const wrappedSelector = React.useCallback({\n            [selector.name] (state) {\n                const selected = selector(state);\n                if (true) {\n                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = {\n                        stabilityCheck,\n                        identityFunctionCheck,\n                        ...devModeChecks\n                    };\n                    if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n                        const toCompare = selector(state);\n                        if (!equalityFn(selected, toCompare)) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                                state,\n                                selected,\n                                selected2: toCompare,\n                                stack\n                            });\n                        }\n                    }\n                    if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n                        if (selected === state) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                                stack\n                            });\n                        }\n                    }\n                    if (firstRun.current) firstRun.current = false;\n                }\n                return selected;\n            }\n        }[selector.name], [\n            selector,\n            stabilityCheck,\n            devModeChecks.stabilityCheck\n        ]);\n        const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n        React.useDebugValue(selectedState);\n        return selectedState;\n    };\n    Object.assign(useSelector2, {\n        withTypes: ()=>useSelector2\n    });\n    return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n// src/utils/react-is.ts\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\nvar REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\nvar REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\nvar REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\nvar REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n    if (typeof type === \"string\" || typeof type === \"function\") {\n        return true;\n    }\n    if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n        return true;\n    }\n    if (typeof type === \"object\" && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction typeOf(object) {\n    if (typeof object === \"object\" && object !== null) {\n        const $$typeof = object.$$typeof;\n        switch($$typeof){\n            case REACT_ELEMENT_TYPE:\n                {\n                    const type = object.type;\n                    switch(type){\n                        case REACT_FRAGMENT_TYPE:\n                        case REACT_PROFILER_TYPE:\n                        case REACT_STRICT_MODE_TYPE:\n                        case REACT_SUSPENSE_TYPE:\n                        case REACT_SUSPENSE_LIST_TYPE:\n                            return type;\n                        default:\n                            {\n                                const $$typeofType = type && type.$$typeof;\n                                switch($$typeofType){\n                                    case REACT_SERVER_CONTEXT_TYPE:\n                                    case REACT_CONTEXT_TYPE:\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_LAZY_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                    case REACT_PROVIDER_TYPE:\n                                        return $$typeofType;\n                                    default:\n                                        return $$typeof;\n                                }\n                            }\n                    }\n                }\n            case REACT_PORTAL_TYPE:\n                {\n                    return $$typeof;\n                }\n        }\n    }\n    return void 0;\n}\nfunction isContextConsumer(object) {\n    return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n}\n// src/utils/warning.ts\nfunction warning(message) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    try {\n        throw new Error(message);\n    } catch (e) {}\n}\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n    if (!selector) {\n        throw new Error(`Unexpected value for ${methodName} in connect.`);\n    } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n        if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n            warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n        }\n    }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n    verify(mapStateToProps, \"mapStateToProps\");\n    verify(mapDispatchToProps, \"mapDispatchToProps\");\n    verify(mergeProps, \"mergeProps\");\n}\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }) {\n    let hasRunAtLeastOnce = false;\n    let state;\n    let ownProps;\n    let stateProps;\n    let dispatchProps;\n    let mergedProps;\n    function handleFirstCall(firstState, firstOwnProps) {\n        state = firstState;\n        ownProps = firstOwnProps;\n        stateProps = mapStateToProps(state, ownProps);\n        dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        hasRunAtLeastOnce = true;\n        return mergedProps;\n    }\n    function handleNewPropsAndNewState() {\n        stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewProps() {\n        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewState() {\n        const nextStateProps = mapStateToProps(state, ownProps);\n        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n        stateProps = nextStateProps;\n        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleSubsequentCalls(nextState, nextOwnProps) {\n        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n        state = nextState;\n        ownProps = nextOwnProps;\n        if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n        if (propsChanged) return handleNewProps();\n        if (stateChanged) return handleNewState();\n        return mergedProps;\n    }\n    return function pureFinalPropsSelector(nextState, nextOwnProps) {\n        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n    };\n}\nfunction finalPropsSelectorFactory(dispatch, { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }) {\n    const mapStateToProps = initMapStateToProps(dispatch, options);\n    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n    const mergeProps = initMergeProps(dispatch, options);\n    if (true) {\n        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n    }\n    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = (...args)=>dispatch(actionCreator(...args));\n        }\n    }\n    return boundActionCreators;\n}\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null) return true;\n    let baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n    if (!isPlainObject(value)) {\n        warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n    }\n}\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n    return function initConstantSelector(dispatch) {\n        const constant = getConstant(dispatch);\n        function constantSelector() {\n            return constant;\n        }\n        constantSelector.dependsOnOwnProps = false;\n        return constantSelector;\n    };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n    return function initProxySelector(dispatch, { displayName }) {\n        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n        };\n        proxy.dependsOnOwnProps = true;\n        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n            proxy.mapToProps = mapToProps;\n            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n            let props = proxy(stateOrDispatch, ownProps);\n            if (typeof props === \"function\") {\n                proxy.mapToProps = props;\n                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n                props = proxy(stateOrDispatch, ownProps);\n            }\n            if (true) verifyPlainObject(props, displayName, methodName);\n            return props;\n        };\n        return proxy;\n    };\n}\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n    return (dispatch, options)=>{\n        throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n    };\n}\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n    return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({\n            dispatch\n        })) : typeof mapDispatchToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n    return {\n        ...ownProps,\n        ...stateProps,\n        ...dispatchProps\n    };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n    return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {\n        let hasRunOnce = false;\n        let mergedProps;\n        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n            if (hasRunOnce) {\n                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n            } else {\n                hasRunOnce = true;\n                mergedProps = nextMergedProps;\n                if (true) verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n            }\n            return mergedProps;\n        };\n    };\n}\nfunction mergePropsFactory(mergeProps) {\n    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n    callback();\n}\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n    let first = null;\n    let last = null;\n    return {\n        clear () {\n            first = null;\n            last = null;\n        },\n        notify () {\n            defaultNoopBatch(()=>{\n                let listener = first;\n                while(listener){\n                    listener.callback();\n                    listener = listener.next;\n                }\n            });\n        },\n        get () {\n            const listeners = [];\n            let listener = first;\n            while(listener){\n                listeners.push(listener);\n                listener = listener.next;\n            }\n            return listeners;\n        },\n        subscribe (callback) {\n            let isSubscribed = true;\n            const listener = last = {\n                callback,\n                next: null,\n                prev: last\n            };\n            if (listener.prev) {\n                listener.prev.next = listener;\n            } else {\n                first = listener;\n            }\n            return function unsubscribe() {\n                if (!isSubscribed || first === null) return;\n                isSubscribed = false;\n                if (listener.next) {\n                    listener.next.prev = listener.prev;\n                } else {\n                    last = listener.prev;\n                }\n                if (listener.prev) {\n                    listener.prev.next = listener.next;\n                } else {\n                    first = listener.next;\n                }\n            };\n        }\n    };\n}\nvar nullListeners = {\n    notify () {},\n    get: ()=>[]\n};\nfunction createSubscription(store, parentSub) {\n    let unsubscribe;\n    let listeners = nullListeners;\n    let subscriptionsAmount = 0;\n    let selfSubscribed = false;\n    function addNestedSub(listener) {\n        trySubscribe();\n        const cleanupListener = listeners.subscribe(listener);\n        let removed = false;\n        return ()=>{\n            if (!removed) {\n                removed = true;\n                cleanupListener();\n                tryUnsubscribe();\n            }\n        };\n    }\n    function notifyNestedSubs() {\n        listeners.notify();\n    }\n    function handleChangeWrapper() {\n        if (subscription.onStateChange) {\n            subscription.onStateChange();\n        }\n    }\n    function isSubscribed() {\n        return selfSubscribed;\n    }\n    function trySubscribe() {\n        subscriptionsAmount++;\n        if (!unsubscribe) {\n            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n            listeners = createListenerCollection();\n        }\n    }\n    function tryUnsubscribe() {\n        subscriptionsAmount--;\n        if (unsubscribe && subscriptionsAmount === 0) {\n            unsubscribe();\n            unsubscribe = void 0;\n            listeners.clear();\n            listeners = nullListeners;\n        }\n    }\n    function trySubscribeSelf() {\n        if (!selfSubscribed) {\n            selfSubscribed = true;\n            trySubscribe();\n        }\n    }\n    function tryUnsubscribeSelf() {\n        if (selfSubscribed) {\n            selfSubscribed = false;\n            tryUnsubscribe();\n        }\n    }\n    const subscription = {\n        addNestedSub,\n        notifyNestedSubs,\n        handleChangeWrapper,\n        isSubscribed,\n        trySubscribe: trySubscribeSelf,\n        tryUnsubscribe: tryUnsubscribeSelf,\n        getListeners: ()=>listeners\n    };\n    return subscription;\n}\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = !!( false && 0);\nvar isReactNative = typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar useIsomorphicLayoutEffect = canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect;\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction shallowEqual(objA, objB) {\n    if (is(objA, objB)) return true;\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n    for(let i = 0; i < keysA.length; i++){\n        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar FORWARD_REF_STATICS = {\n    $$typeof: true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n};\nvar MEMO_STATICS = {\n    $$typeof: true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n};\nvar TYPE_STATICS = {\n    [ForwardRef]: FORWARD_REF_STATICS,\n    [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n    if (isMemo(component)) {\n        return MEMO_STATICS;\n    }\n    return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n    if (typeof sourceComponent !== \"string\") {\n        if (objectPrototype) {\n            const inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent);\n            }\n        }\n        let keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        const targetStatics = getStatics(targetComponent);\n        const sourceStatics = getStatics(sourceComponent);\n        for(let i = 0; i < keys.length; ++i){\n            const key = keys[i];\n            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n    }\n    return targetComponent;\n}\n// src/components/connect.tsx\nvar useSyncExternalStore = notInitialized;\nvar initializeConnect = (fn)=>{\n    useSyncExternalStore = fn;\n};\nvar NO_SUBSCRIPTION_ARRAY = [\n    null,\n    null\n];\nvar stringifyComponent = (Comp)=>{\n    try {\n        return JSON.stringify(Comp);\n    } catch (err) {\n        return String(Comp);\n    }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n    useIsomorphicLayoutEffect(()=>effectFunc(...effectArgs), dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n    lastWrapperProps.current = wrapperProps;\n    renderIsScheduled.current = false;\n    if (childPropsFromStoreUpdate.current) {\n        childPropsFromStoreUpdate.current = null;\n        notifyNestedSubs();\n    }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n    if (!shouldHandleStateChanges) return ()=>{};\n    let didUnsubscribe = false;\n    let lastThrownError = null;\n    const checkForUpdates = ()=>{\n        if (didUnsubscribe || !isMounted.current) {\n            return;\n        }\n        const latestStoreState = store.getState();\n        let newChildProps, error;\n        try {\n            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n        } catch (e) {\n            error = e;\n            lastThrownError = e;\n        }\n        if (!error) {\n            lastThrownError = null;\n        }\n        if (newChildProps === lastChildProps.current) {\n            if (!renderIsScheduled.current) {\n                notifyNestedSubs();\n            }\n        } else {\n            lastChildProps.current = newChildProps;\n            childPropsFromStoreUpdate.current = newChildProps;\n            renderIsScheduled.current = true;\n            additionalSubscribeListener();\n        }\n    };\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    const unsubscribeWrapper = ()=>{\n        didUnsubscribe = true;\n        subscription.tryUnsubscribe();\n        subscription.onStateChange = null;\n        if (lastThrownError) {\n            throw lastThrownError;\n        }\n    };\n    return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n    return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n// @ts-ignore\npure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component\nforwardRef = false, // the context consumer to use\ncontext = ReactReduxContext } = {}) {\n    if (true) {\n        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n            hasWarnedAboutDeprecatedPureOption = true;\n            warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n        }\n    }\n    const Context = context;\n    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n    const initMergeProps = mergePropsFactory(mergeProps);\n    const shouldHandleStateChanges = Boolean(mapStateToProps);\n    const wrapWithConnect = (WrappedComponent)=>{\n        if (true) {\n            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n            if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);\n        }\n        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n        const displayName = `Connect(${wrappedComponentName})`;\n        const selectorFactoryOptions = {\n            shouldHandleStateChanges,\n            displayName,\n            wrappedComponentName,\n            WrappedComponent,\n            // @ts-ignore\n            initMapStateToProps,\n            // @ts-ignore\n            initMapDispatchToProps,\n            initMergeProps,\n            areStatesEqual,\n            areStatePropsEqual,\n            areOwnPropsEqual,\n            areMergedPropsEqual\n        };\n        function ConnectFunction(props) {\n            const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(()=>{\n                const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n                return [\n                    props.context,\n                    reactReduxForwardedRef2,\n                    wrapperProps2\n                ];\n            }, [\n                props\n            ]);\n            const ContextToUse = React.useMemo(()=>{\n                let ResultContext = Context;\n                if (propsContext?.Consumer) {\n                    if (true) {\n                        const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore\n                        /* @__PURE__ */ React.createElement(propsContext.Consumer, null));\n                        if (!isValid) {\n                            throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n                        }\n                        ResultContext = propsContext;\n                    }\n                }\n                return ResultContext;\n            }, [\n                propsContext,\n                Context\n            ]);\n            const contextValue = React.useContext(ContextToUse);\n            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n            if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n                throw new Error(`Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);\n            }\n            const store = didStoreComeFromProps ? props.store : contextValue.store;\n            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n            const childPropsSelector = React.useMemo(()=>{\n                return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n            }, [\n                store\n            ]);\n            const [subscription, notifyNestedSubs] = React.useMemo(()=>{\n                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n                const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n                const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n                return [\n                    subscription2,\n                    notifyNestedSubs2\n                ];\n            }, [\n                store,\n                didStoreComeFromProps,\n                contextValue\n            ]);\n            const overriddenContextValue = React.useMemo(()=>{\n                if (didStoreComeFromProps) {\n                    return contextValue;\n                }\n                return {\n                    ...contextValue,\n                    subscription\n                };\n            }, [\n                didStoreComeFromProps,\n                contextValue,\n                subscription\n            ]);\n            const lastChildProps = React.useRef(void 0);\n            const lastWrapperProps = React.useRef(wrapperProps);\n            const childPropsFromStoreUpdate = React.useRef(void 0);\n            const renderIsScheduled = React.useRef(false);\n            const isMounted = React.useRef(false);\n            const latestSubscriptionCallbackError = React.useRef(void 0);\n            useIsomorphicLayoutEffect(()=>{\n                isMounted.current = true;\n                return ()=>{\n                    isMounted.current = false;\n                };\n            }, []);\n            const actualChildPropsSelector = React.useMemo(()=>{\n                const selector = ()=>{\n                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n                        return childPropsFromStoreUpdate.current;\n                    }\n                    return childPropsSelector(store.getState(), wrapperProps);\n                };\n                return selector;\n            }, [\n                store,\n                wrapperProps\n            ]);\n            const subscribeForReact = React.useMemo(()=>{\n                const subscribe = (reactListener)=>{\n                    if (!subscription) {\n                        return ()=>{};\n                    }\n                    return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n                    childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n                };\n                return subscribe;\n            }, [\n                subscription\n            ]);\n            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n                lastWrapperProps,\n                lastChildProps,\n                renderIsScheduled,\n                wrapperProps,\n                childPropsFromStoreUpdate,\n                notifyNestedSubs\n            ]);\n            let actualChildProps;\n            try {\n                actualChildProps = useSyncExternalStore(// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n                actualChildPropsSelector, getServerState ? ()=>childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n            } catch (err) {\n                if (latestSubscriptionCallbackError.current) {\n                    ;\n                    err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n                }\n                throw err;\n            }\n            useIsomorphicLayoutEffect(()=>{\n                latestSubscriptionCallbackError.current = void 0;\n                childPropsFromStoreUpdate.current = void 0;\n                lastChildProps.current = actualChildProps;\n            });\n            const renderedWrappedComponent = React.useMemo(()=>{\n                return(// @ts-ignore\n                /* @__PURE__ */ React.createElement(WrappedComponent, {\n                    ...actualChildProps,\n                    ref: reactReduxForwardedRef\n                }));\n            }, [\n                reactReduxForwardedRef,\n                WrappedComponent,\n                actualChildProps\n            ]);\n            const renderedChild = React.useMemo(()=>{\n                if (shouldHandleStateChanges) {\n                    return /* @__PURE__ */ React.createElement(ContextToUse.Provider, {\n                        value: overriddenContextValue\n                    }, renderedWrappedComponent);\n                }\n                return renderedWrappedComponent;\n            }, [\n                ContextToUse,\n                renderedWrappedComponent,\n                overriddenContextValue\n            ]);\n            return renderedChild;\n        }\n        const _Connect = React.memo(ConnectFunction);\n        const Connect = _Connect;\n        Connect.WrappedComponent = WrappedComponent;\n        Connect.displayName = ConnectFunction.displayName = displayName;\n        if (forwardRef) {\n            const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n                return /* @__PURE__ */ React.createElement(Connect, {\n                    ...props,\n                    reactReduxForwardedRef: ref\n                });\n            });\n            const forwarded = _forwarded;\n            forwarded.displayName = displayName;\n            forwarded.WrappedComponent = WrappedComponent;\n            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n        }\n        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n    };\n    return wrapWithConnect;\n}\nvar connect_default = connect;\n// src/components/Provider.tsx\nfunction Provider({ store, context, children, serverState, stabilityCheck = \"once\", identityFunctionCheck = \"once\" }) {\n    const contextValue = React.useMemo(()=>{\n        const subscription = createSubscription(store);\n        return {\n            store,\n            subscription,\n            getServerState: serverState ? ()=>serverState : void 0,\n            stabilityCheck,\n            identityFunctionCheck\n        };\n    }, [\n        store,\n        serverState,\n        stabilityCheck,\n        identityFunctionCheck\n    ]);\n    const previousState = React.useMemo(()=>store.getState(), [\n        store\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        const { subscription } = contextValue;\n        subscription.onStateChange = subscription.notifyNestedSubs;\n        subscription.trySubscribe();\n        if (previousState !== store.getState()) {\n            subscription.notifyNestedSubs();\n        }\n        return ()=>{\n            subscription.tryUnsubscribe();\n            subscription.onStateChange = void 0;\n        };\n    }, [\n        contextValue,\n        previousState\n    ]);\n    const Context = context || ReactReduxContext;\n    return /* @__PURE__ */ React.createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\nvar Provider_default = Provider;\n// src/hooks/useStore.ts\nfunction createStoreHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore\n    createReduxContextHook(context);\n    const useStore2 = ()=>{\n        const { store } = useReduxContext2();\n        return store;\n    };\n    Object.assign(useStore2, {\n        withTypes: ()=>useStore2\n    });\n    return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n// src/hooks/useDispatch.ts\nfunction createDispatchHook(context = ReactReduxContext) {\n    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n    const useDispatch2 = ()=>{\n        const store = useStore2();\n        return store.dispatch;\n    };\n    Object.assign(useDispatch2, {\n        withTypes: ()=>useDispatch2\n    });\n    return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n// src/exports.ts\nvar batch = defaultNoopBatch;\n// src/index.ts\ninitializeUseSelector(use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector);\ninitializeConnect(react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore);\n //# sourceMappingURL=react-redux.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2lCO0FBQ2lHO0FBRWpJLHFCQUFxQjtBQUNrQjtBQUN2QyxJQUFJSSxRQUNGLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsS0FBMEJELEdBQUdBLGtDQUF3QixHQUFHQSx5TEFBYUE7QUFHdkUsNEJBQTRCO0FBQzVCLElBQUlFLGFBQWFDLE9BQU9DLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixDQUFDO0FBQ2pELElBQUlDLEtBQUssT0FBT0MsZUFBZSxjQUFjQSxhQUMzQyx3RkFBd0YsR0FDeEYsQ0FBQztBQUVILFNBQVNDO0lBQ1AsSUFBSSxDQUFDTixNQUFNTyxhQUFhLEVBQ3RCLE9BQU8sQ0FBQztJQUNWLE1BQU1DLGFBQWFKLEVBQUUsQ0FBQ0gsV0FBVyxJQUFLRyxDQUFBQSxFQUFFLENBQUNILFdBQVcsR0FBRyxhQUFhLEdBQUcsSUFBSVEsS0FBSTtJQUMvRSxJQUFJQyxjQUFjRixXQUFXRyxHQUFHLENBQUNYLE1BQU1PLGFBQWE7SUFDcEQsSUFBSSxDQUFDRyxhQUFhO1FBQ2hCQSxjQUFjVixNQUFNTyxhQUFhLENBQy9CO1FBRUYsSUFBSUssSUFBcUMsRUFBRTtZQUN6Q0YsWUFBWUcsV0FBVyxHQUFHO1FBQzVCO1FBQ0FMLFdBQVdNLEdBQUcsQ0FBQ2QsTUFBTU8sYUFBYSxFQUFFRztJQUN0QztJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJSyxvQkFBb0IsYUFBYSxHQUFHVDtBQUV4QyxvQ0FBb0M7QUFDcEMsSUFBSVUsaUJBQWlCO0lBQ25CLE1BQU0sSUFBSUMsTUFBTTtBQUNsQjtBQUVBLCtCQUErQjtBQUMvQixTQUFTQyx1QkFBdUJDLFVBQVVKLGlCQUFpQjtJQUN6RCxPQUFPLFNBQVNLO1FBQ2QsTUFBTUMsZUFBZXJCLE1BQU1zQixVQUFVLENBQUNIO1FBQ3RDLElBQUlQLEtBQXFDLElB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d0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mb29kaWVzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2Rpc3QvcmVhY3QtcmVkdXgubWpzPzA0MjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgKiBhcyBSZWFjdDIgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qc1wiO1xuXG4vLyBzcmMvdXRpbHMvcmVhY3QudHNcbmltcG9ydCAqIGFzIFJlYWN0T3JpZ2luYWwgZnJvbSBcInJlYWN0XCI7XG52YXIgUmVhY3QgPSAoXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICAvLyBAdHMtaWdub3JlXG4gIFwiZGVmYXVsdFwiIGluIFJlYWN0T3JpZ2luYWwgPyBSZWFjdE9yaWdpbmFsW1wiZGVmYXVsdFwiXSA6IFJlYWN0T3JpZ2luYWxcbik7XG5cbi8vIHNyYy9jb21wb25lbnRzL0NvbnRleHQudHNcbnZhciBDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihgcmVhY3QtcmVkdXgtY29udGV4dGApO1xudmFyIGdUID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogKFxuICAvKiBmYWxsIGJhY2sgdG8gYSBwZXItbW9kdWxlIHNjb3BlIChwcmUtOC4xIGJlaGF2aW91cikgaWYgYGdsb2JhbFRoaXNgIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAge31cbik7XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIVJlYWN0LmNyZWF0ZUNvbnRleHQpXG4gICAgcmV0dXJuIHt9O1xuICBjb25zdCBjb250ZXh0TWFwID0gZ1RbQ29udGV4dEtleV0gPz8gKGdUW0NvbnRleHRLZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGxldCByZWFsQ29udGV4dCA9IGNvbnRleHRNYXAuZ2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQpO1xuICBpZiAoIXJlYWxDb250ZXh0KSB7XG4gICAgcmVhbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVhbENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJlYWN0UmVkdXhcIjtcbiAgICB9XG4gICAgY29udGV4dE1hcC5zZXQoUmVhY3QuY3JlYXRlQ29udGV4dCwgcmVhbENvbnRleHQpO1xuICB9XG4gIHJldHVybiByZWFsQ29udGV4dDtcbn1cbnZhciBSZWFjdFJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBnZXRDb250ZXh0KCk7XG5cbi8vIHNyYy91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZS50c1xudmFyIG5vdEluaXRpYWxpemVkID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1U0VTIG5vdCBpbml0aWFsaXplZCFcIik7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlUmVkdXhDb250ZXh0LnRzXG5mdW5jdGlvbiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gdXNlUmVkdXhDb250ZXh0MigpIHtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWNvbnRleHRWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImNvdWxkIG5vdCBmaW5kIHJlYWN0LXJlZHV4IGNvbnRleHQgdmFsdWU7IHBsZWFzZSBlbnN1cmUgdGhlIGNvbXBvbmVudCBpcyB3cmFwcGVkIGluIGEgPFByb3ZpZGVyPlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICB9O1xufVxudmFyIHVzZVJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVSZWR1eENvbnRleHRIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VTZWxlY3Rvci50c1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZVVzZVNlbGVjdG9yID0gKGZuKSA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gZm47XG59O1xudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rvckhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZVNlbGVjdG9yMiA9IChzZWxlY3RvciwgZXF1YWxpdHlGbk9yT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHksIGRldk1vZGVDaGVja3MgPSB7fSB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHsgZXF1YWxpdHlGbjogZXF1YWxpdHlGbk9yT3B0aW9ucyB9IDogZXF1YWxpdHlGbk9yT3B0aW9ucztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYW4gZXF1YWxpdHkgZnVuY3Rpb24gdG8gdXNlU2VsZWN0b3JgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGUsXG4gICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgY29uc3QgZmlyc3RSdW4gPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICB7XG4gICAgICAgIFtzZWxlY3Rvci5uYW1lXShzdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2s6IGZpbmFsU3RhYmlsaXR5Q2hlY2tcbiAgICAgICAgICAgIH0gPSB7XG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgICAgICAgICAgIC4uLmRldk1vZGVDaGVja3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gXCJhbHdheXNcIiB8fCBmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvQ29tcGFyZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgICAgICAgaWYgKCFlcXVhbGl0eUZuKHNlbGVjdGVkLCB0b0NvbXBhcmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiU2VsZWN0b3IgXCIgKyAoc2VsZWN0b3IubmFtZSB8fCBcInVua25vd25cIikgKyBcIiByZXR1cm5lZCBhIGRpZmZlcmVudCByZXN1bHQgd2hlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gYSBuZXcgcmVmZXJlbmNlIChzdWNoIGFzIGFuIG9iamVjdCBvciBhbiBhcnJheSkgc2hvdWxkIGJlIG1lbW9pemVkOiBodHRwczovL3JlZHV4LmpzLm9yZy91c2FnZS9kZXJpdmluZy1kYXRhLXNlbGVjdG9ycyNvcHRpbWl6aW5nLXNlbGVjdG9ycy13aXRoLW1lbW9pemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQyOiB0b0NvbXBhcmUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIHRoZSByb290IHN0YXRlIHdoZW4gY2FsbGVkLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZSBhcmUgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UsIGFzIHRoZXkgd2lsbCBjYXVzZSBhIHJlcmVuZGVyIHdoZW5ldmVyICphbnl0aGluZyogaW4gc3RhdGUgY2hhbmdlcy5cIixcbiAgICAgICAgICAgICAgICAgIHsgc3RhY2sgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFJ1bi5jdXJyZW50KVxuICAgICAgICAgICAgICBmaXJzdFJ1bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfVtzZWxlY3Rvci5uYW1lXSxcbiAgICAgIFtzZWxlY3Rvciwgc3RhYmlsaXR5Q2hlY2ssIGRldk1vZGVDaGVja3Muc3RhYmlsaXR5Q2hlY2tdXG4gICAgKTtcbiAgICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdWJzY3JpcHRpb24uYWRkTmVzdGVkU3ViLFxuICAgICAgc3RvcmUuZ2V0U3RhdGUsXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSB8fCBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGVxdWFsaXR5Rm5cbiAgICApO1xuICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU2VsZWN0b3IyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTZWxlY3RvcjJcbiAgfSk7XG4gIHJldHVybiB1c2VTZWxlY3RvcjI7XG59XG52YXIgdXNlU2VsZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2VsZWN0b3JIb29rKCk7XG5cbi8vIHNyYy91dGlscy9yZWFjdC1pcy50c1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpO1xudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc2VydmVyX2NvbnRleHRcIik7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIik7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6IHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRToge1xuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuXG4vLyBzcmMvdXRpbHMvd2FybmluZy50c1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICB0cnkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy50c1xuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lKSB7XG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgZm9yICR7bWV0aG9kTmFtZX0gaW4gY29ubmVjdC5gKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSBcIm1hcFN0YXRlVG9Qcm9wc1wiIHx8IG1ldGhvZE5hbWUgPT09IFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxlY3RvciwgXCJkZXBlbmRzT25Pd25Qcm9wc1wiKSkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYFRoZSBzZWxlY3RvciBmb3IgJHttZXRob2ROYW1lfSBvZiBjb25uZWN0IGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKTtcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsIFwibWVyZ2VQcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LnRzXG5mdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIHtcbiAgYXJlU3RhdGVzRXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbFxufSkge1xuICBsZXQgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgbGV0IHN0YXRlO1xuICBsZXQgb3duUHJvcHM7XG4gIGxldCBzdGF0ZVByb3BzO1xuICBsZXQgZGlzcGF0Y2hQcm9wcztcbiAgbGV0IG1lcmdlZFByb3BzO1xuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpIHtcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wcygpIHtcbiAgICBpZiAobWFwU3RhdGVUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3U3RhdGUoKSB7XG4gICAgY29uc3QgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpXG4gICAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwoXG4gICAgICBuZXh0U3RhdGUsXG4gICAgICBzdGF0ZSxcbiAgICAgIG5leHRPd25Qcm9wcyxcbiAgICAgIG93blByb3BzXG4gICAgKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcbiAgICBpZiAocHJvcHNDaGFuZ2VkICYmIHN0YXRlQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpXG4gICAgICByZXR1cm4gaGFuZGxlTmV3U3RhdGUoKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIHtcbiAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgaW5pdE1lcmdlUHJvcHMsXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gaW5pdE1hcFN0YXRlVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKTtcbiAgfVxuICByZXR1cm4gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycy50c1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBjb25zdCBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9ICguLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cbi8vIHNyYy91dGlscy9pc1BsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGxldCBiYXNlUHJvdG8gPSBwcm90bztcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XG4gICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90byk7XG4gIH1cbiAgcmV0dXJuIHByb3RvID09PSBiYXNlUHJvdG87XG59XG5cbi8vIHNyYy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgYCR7bWV0aG9kTmFtZX0oKSBpbiAke2Rpc3BsYXlOYW1lfSBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3ZhbHVlfS5gXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy50c1xuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoKTtcbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufVxuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lIH0pIHtcbiAgICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIHZvaWQgMCk7XG4gICAgfTtcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgbGV0IHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L2ludmFsaWRBcmdGYWN0b3J5LnRzXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShhcmcsIG5hbWUpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYXJnfSBmb3IgJHtuYW1lfSBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICR7b3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZX0uYFxuICAgICk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcIm9iamVjdFwiID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChcbiAgICAoZGlzcGF0Y2gpID0+IChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKVxuICAgIClcbiAgKSA6ICFtYXBEaXNwYXRjaFRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KChkaXNwYXRjaCkgPT4gKHtcbiAgICBkaXNwYXRjaFxuICB9KSkgOiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpXG4gICkgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMudHNcbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoKSA9PiAoe30pKSA6IHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21lcmdlUHJvcHMudHNcbmZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIHJldHVybiB7IC4uLm93blByb3BzLCAuLi5zdGF0ZVByb3BzLCAuLi5kaXNwYXRjaFByb3BzIH07XG59XG5mdW5jdGlvbiB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdE1lcmdlUHJvcHNQcm94eShkaXNwYXRjaCwgeyBkaXNwbGF5TmFtZSwgYXJlTWVyZ2VkUHJvcHNFcXVhbCB9KSB7XG4gICAgbGV0IGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgICBsZXQgbWVyZ2VkUHJvcHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgY29uc3QgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpXG4gICAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNSdW5PbmNlID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCBcIm1lcmdlUHJvcHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gKCkgPT4gZGVmYXVsdE1lcmdlUHJvcHMgOiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmF0Y2gudHNcbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxuLy8gc3JjL3V0aWxzL1N1YnNjcmlwdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICBsZXQgZmlyc3QgPSBudWxsO1xuICBsZXQgbGFzdCA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgY2xlYXIoKSB7XG4gICAgICBmaXJzdCA9IG51bGw7XG4gICAgICBsYXN0ID0gbnVsbDtcbiAgICB9LFxuICAgIG5vdGlmeSgpIHtcbiAgICAgIGRlZmF1bHROb29wQmF0Y2goKCkgPT4ge1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBsYXN0ID0ge1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgcHJldjogbGFzdFxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgZmlyc3QgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLm5leHQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5uZXh0LnByZXYgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxudmFyIG51bGxMaXN0ZW5lcnMgPSB7XG4gIG5vdGlmeSgpIHtcbiAgfSxcbiAgZ2V0OiAoKSA9PiBbXVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViKSB7XG4gIGxldCB1bnN1YnNjcmliZTtcbiAgbGV0IGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gIGxldCBzdWJzY3JpcHRpb25zQW1vdW50ID0gMDtcbiAgbGV0IHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcikge1xuICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIGNvbnN0IGNsZWFudXBMaXN0ZW5lciA9IGxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcmVtb3ZlZCkge1xuICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyKCk7XG4gICAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzKCkge1xuICAgIGxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmIChzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBzZWxmU3Vic2NyaWJlZDtcbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgc3Vic2NyaXB0aW9uc0Ftb3VudCsrO1xuICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlID0gcGFyZW50U3ViID8gcGFyZW50U3ViLmFkZE5lc3RlZFN1YihoYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2VXcmFwcGVyKTtcbiAgICAgIGxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50LS07XG4gICAgaWYgKHVuc3Vic2NyaWJlICYmIHN1YnNjcmlwdGlvbnNBbW91bnQgPT09IDApIHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB1bnN1YnNjcmliZSA9IHZvaWQgMDtcbiAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoIXNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICB0cnlTdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmIChzZWxmU3Vic2NyaWJlZCkge1xuICAgICAgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICBhZGROZXN0ZWRTdWIsXG4gICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICBoYW5kbGVDaGFuZ2VXcmFwcGVyLFxuICAgIGlzU3Vic2NyaWJlZCxcbiAgICB0cnlTdWJzY3JpYmU6IHRyeVN1YnNjcmliZVNlbGYsXG4gICAgdHJ5VW5zdWJzY3JpYmU6IHRyeVVuc3Vic2NyaWJlU2VsZixcbiAgICBnZXRMaXN0ZW5lcnM6ICgpID0+IGxpc3RlbmVyc1xuICB9O1xuICByZXR1cm4gc3Vic2NyaXB0aW9uO1xufVxuXG4vLyBzcmMvdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdC50c1xudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpO1xudmFyIGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCI7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGNhblVzZURPTSB8fCBpc1JlYWN0TmF0aXZlID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuXG4vLyBzcmMvdXRpbHMvc2hhbGxvd0VxdWFsLnRzXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy91dGlscy9ob2lzdFN0YXRpY3MudHNcbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZVxufTtcbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge1xuICBbRm9yd2FyZFJlZl06IEZPUldBUkRfUkVGX1NUQVRJQ1MsXG4gIFtNZW1vXTogTUVNT19TVEFUSUNTXG59O1xuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgaWYgKGlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfVxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFtcIiQkdHlwZW9mXCJdXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgY29uc3QgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIGNvbnN0IHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvY29ubmVjdC50c3hcbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IG5vdEluaXRpYWxpemVkO1xudmFyIGluaXRpYWxpemVDb25uZWN0ID0gKGZuKSA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gZm47XG59O1xudmFyIE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXTtcbnZhciBzdHJpbmdpZnlDb21wb25lbnQgPSAoQ29tcCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZyhDb21wKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhlZmZlY3RGdW5jLCBlZmZlY3RBcmdzLCBkZXBlbmRlbmNpZXMpIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBlZmZlY3RGdW5jKC4uLmVmZmVjdEFyZ3MpLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gY2FwdHVyZVdyYXBwZXJQcm9wcyhsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIHdyYXBwZXJQcm9wcywgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3Vicykge1xuICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQgPSB3cmFwcGVyUHJvcHM7XG4gIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCkge1xuICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG51bGw7XG4gICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmVVcGRhdGVzKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcywgc3RvcmUsIHN1YnNjcmlwdGlvbiwgY2hpbGRQcm9wc1NlbGVjdG9yLCBsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIGlzTW91bnRlZCwgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3VicywgYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyKSB7XG4gIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgbGV0IGRpZFVuc3Vic2NyaWJlID0gZmFsc2U7XG4gIGxldCBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICBjb25zdCBjaGVja0ZvclVwZGF0ZXMgPSAoKSA9PiB7XG4gICAgaWYgKGRpZFVuc3Vic2NyaWJlIHx8ICFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXRlc3RTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgbmV3Q2hpbGRQcm9wcywgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NoaWxkUHJvcHMgPSBjaGlsZFByb3BzU2VsZWN0b3IoXG4gICAgICAgIGxhdGVzdFN0b3JlU3RhdGUsXG4gICAgICAgIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGU7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobmV3Q2hpbGRQcm9wcyA9PT0gbGFzdENoaWxkUHJvcHMuY3VycmVudCkge1xuICAgICAgaWYgKCFyZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50KSB7XG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IHRydWU7XG4gICAgICBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIoKTtcbiAgICB9XG4gIH07XG4gIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzO1xuICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gIGNoZWNrRm9yVXBkYXRlcygpO1xuICBjb25zdCB1bnN1YnNjcmliZVdyYXBwZXIgPSAoKSA9PiB7XG4gICAgZGlkVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcbiAgICBpZiAobGFzdFRocm93bkVycm9yKSB7XG4gICAgICB0aHJvdyBsYXN0VGhyb3duRXJyb3I7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdW5zdWJzY3JpYmVXcmFwcGVyO1xufVxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCB7XG4gIC8vIFRoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQsIHNvIFRTIGRvZXNuJ3QgbGlrZSB1cyBkZXN0cnVjdHVyaW5nIHRoaXMgdG8gY2hlY2sgaXRzIGV4aXN0ZW5jZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBwdXJlLFxuICBhcmVTdGF0ZXNFcXVhbCA9IHN0cmljdEVxdWFsLFxuICBhcmVPd25Qcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIC8vIHVzZSBSZWFjdCdzIGZvcndhcmRSZWYgdG8gZXhwb3NlIGEgcmVmIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudFxuICBmb3J3YXJkUmVmID0gZmFsc2UsXG4gIC8vIHRoZSBjb250ZXh0IGNvbnN1bWVyIHRvIHVzZVxuICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHRcbn0gPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHB1cmUgIT09IHZvaWQgMCAmJiAhaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbikge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAnVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gYGNvbm5lY3RgIGlzIG5vdyBhbHdheXMgYSBcInB1cmUvbWVtb2l6ZWRcIiBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dDtcbiAgY29uc3QgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1lcmdlUHJvcHMgPSBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKTtcbiAgY29uc3Qgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCB3cmFwV2l0aENvbm5lY3QgPSAoV3JhcHBlZENvbXBvbmVudCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiBAX19QVVJFX18gKi8gaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGNvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHtzdHJpbmdpZnlDb21wb25lbnQoXG4gICAgICAgICAgICBXcmFwcGVkQ29tcG9uZW50XG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRDb21wb25lbnROYW1lID0gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIjtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGBDb25uZWN0KCR7d3JhcHBlZENvbXBvbmVudE5hbWV9KWA7XG4gICAgY29uc3Qgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIENvbm5lY3RGdW5jdGlvbihwcm9wcykge1xuICAgICAgY29uc3QgW3Byb3BzQ29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgd3JhcHBlclByb3BzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyLCAuLi53cmFwcGVyUHJvcHMyIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIFtwcm9wcy5jb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgd3JhcHBlclByb3BzMl07XG4gICAgICB9LCBbcHJvcHNdKTtcbiAgICAgIGNvbnN0IENvbnRleHRUb1VzZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBsZXQgUmVzdWx0Q29udGV4dCA9IENvbnRleHQ7XG4gICAgICAgIGlmIChwcm9wc0NvbnRleHQ/LkNvbnN1bWVyKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc0NvbnRleHRDb25zdW1lcihcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wc0NvbnRleHQuQ29uc3VtZXIsIG51bGwpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIllvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIGFzIGBwcm9wcy5jb250ZXh0YFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZXN1bHRDb250ZXh0ID0gcHJvcHNDb250ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVzdWx0Q29udGV4dDtcbiAgICAgIH0sIFtwcm9wc0NvbnRleHQsIENvbnRleHRdKTtcbiAgICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dFRvVXNlKTtcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA9IEJvb2xlYW4ocHJvcHMuc3RvcmUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZ2V0U3RhdGUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPSBCb29sZWFuKGNvbnRleHRWYWx1ZSkgJiYgQm9vbGVhbihjb250ZXh0VmFsdWUuc3RvcmUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZGlkU3RvcmVDb21lRnJvbVByb3BzICYmICFkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENvdWxkIG5vdCBmaW5kIFwic3RvcmVcIiBpbiB0aGUgY29udGV4dCBvZiBcIiR7ZGlzcGxheU5hbWV9XCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sIG9yIHBhc3MgYSBjdXN0b20gUmVhY3QgY29udGV4dCBwcm92aWRlciB0byA8UHJvdmlkZXI+IGFuZCB0aGUgY29ycmVzcG9uZGluZyBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIHRvICR7ZGlzcGxheU5hbWV9IGluIGNvbm5lY3Qgb3B0aW9ucy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yZSA9IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHByb3BzLnN0b3JlIDogY29udGV4dFZhbHVlLnN0b3JlO1xuICAgICAgY29uc3QgZ2V0U2VydmVyU3RhdGUgPSBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA/IGNvbnRleHRWYWx1ZS5nZXRTZXJ2ZXJTdGF0ZSA6IHN0b3JlLmdldFN0YXRlO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KHN0b3JlLmRpc3BhdGNoLCBzZWxlY3RvckZhY3RvcnlPcHRpb25zKTtcbiAgICAgIH0sIFtzdG9yZV0pO1xuICAgICAgY29uc3QgW3N1YnNjcmlwdGlvbiwgbm90aWZ5TmVzdGVkU3Vic10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpXG4gICAgICAgICAgcmV0dXJuIE5PX1NVQlNDUklQVElPTl9BUlJBWTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uMiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihcbiAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyB2b2lkIDAgOiBjb250ZXh0VmFsdWUuc3Vic2NyaXB0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG5vdGlmeU5lc3RlZFN1YnMyID0gc3Vic2NyaXB0aW9uMi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQoc3Vic2NyaXB0aW9uMik7XG4gICAgICAgIHJldHVybiBbc3Vic2NyaXB0aW9uMiwgbm90aWZ5TmVzdGVkU3ViczJdO1xuICAgICAgfSwgW3N0b3JlLCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZV0pO1xuICAgICAgY29uc3Qgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoZGlkU3RvcmVDb21lRnJvbVByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNvbnRleHRWYWx1ZSxcbiAgICAgICAgICBzdWJzY3JpcHRpb25cbiAgICAgICAgfTtcbiAgICAgIH0sIFtkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZSwgc3Vic2NyaXB0aW9uXSk7XG4gICAgICBjb25zdCBsYXN0Q2hpbGRQcm9wcyA9IFJlYWN0LnVzZVJlZih2b2lkIDApO1xuICAgICAgY29uc3QgbGFzdFdyYXBwZXJQcm9wcyA9IFJlYWN0LnVzZVJlZih3cmFwcGVyUHJvcHMpO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSA9IFJlYWN0LnVzZVJlZih2b2lkIDApO1xuICAgICAgY29uc3QgcmVuZGVySXNTY2hlZHVsZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSBSZWFjdC51c2VSZWYoXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0sIFtdKTtcbiAgICAgIGNvbnN0IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ICYmIHdyYXBwZXJQcm9wcyA9PT0gbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hpbGRQcm9wc1NlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHdyYXBwZXJQcm9wcyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH0sIFtzdG9yZSwgd3JhcHBlclByb3BzXSk7XG4gICAgICBjb25zdCBzdWJzY3JpYmVGb3JSZWFjdCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmUgPSAocmVhY3RMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmliZVVwZGF0ZXMoXG4gICAgICAgICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNoaWxkUHJvcHNTZWxlY3RvcixcbiAgICAgICAgICAgIGxhc3RXcmFwcGVyUHJvcHMsXG4gICAgICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICAgICAgaXNNb3VudGVkLFxuICAgICAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcbiAgICAgICAgICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgICAgICAgICByZWFjdExpc3RlbmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZTtcbiAgICAgIH0sIFtzdWJzY3JpcHRpb25dKTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhjYXB0dXJlV3JhcHBlclByb3BzLCBbXG4gICAgICAgIGxhc3RXcmFwcGVyUHJvcHMsXG4gICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICByZW5kZXJJc1NjaGVkdWxlZCxcbiAgICAgICAgd3JhcHBlclByb3BzLFxuICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzXG4gICAgICBdKTtcbiAgICAgIGxldCBhY3R1YWxDaGlsZFByb3BzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0dWFsQ2hpbGRQcm9wcyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIC8vIFRPRE8gV2UncmUgcGFzc2luZyB0aHJvdWdoIGEgYmlnIHdyYXBwZXIgdGhhdCBkb2VzIGEgYnVuY2ggb2YgZXh0cmEgc2lkZSBlZmZlY3RzIGJlc2lkZXMgc3Vic2NyaWJpbmdcbiAgICAgICAgICBzdWJzY3JpYmVGb3JSZWFjdCxcbiAgICAgICAgICAvLyBUT0RPIFRoaXMgaXMgaW5jcmVkaWJseSBoYWNreS4gV2UndmUgYWxyZWFkeSBwcm9jZXNzZWQgdGhlIHN0b3JlIHVwZGF0ZSBhbmQgY2FsY3VsYXRlZCBuZXcgY2hpbGQgcHJvcHMsXG4gICAgICAgICAgLy8gVE9ETyBhbmQgd2UncmUganVzdCBwYXNzaW5nIHRoYXQgdGhyb3VnaCBzbyBpdCB0cmlnZ2VycyBhIHJlLXJlbmRlciBmb3IgdXMgcmF0aGVyIHRoYW4gcmVseWluZyBvbiBgdVNFU2AuXG4gICAgICAgICAgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgIGdldFNlcnZlclN0YXRlID8gKCkgPT4gY2hpbGRQcm9wc1NlbGVjdG9yKGdldFNlcnZlclN0YXRlKCksIHdyYXBwZXJQcm9wcykgOiBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3JcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGVyci5tZXNzYWdlICs9IGBcblRoZSBlcnJvciBtYXkgYmUgY29ycmVsYXRlZCB3aXRoIHRoaXMgcHJldmlvdXMgZXJyb3I6XG4ke2xhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudC5zdGFja31cblxuYDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBhY3R1YWxDaGlsZFByb3BzO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5hY3R1YWxDaGlsZFByb3BzLFxuICAgICAgICAgICAgICByZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LCBbcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgV3JhcHBlZENvbXBvbmVudCwgYWN0dWFsQ2hpbGRQcm9wc10pO1xuICAgICAgY29uc3QgcmVuZGVyZWRDaGlsZCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRUb1VzZS5Qcm92aWRlciwgeyB2YWx1ZTogb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSB9LCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICB9LCBbQ29udGV4dFRvVXNlLCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQsIG92ZXJyaWRkZW5Db250ZXh0VmFsdWVdKTtcbiAgICAgIHJldHVybiByZW5kZXJlZENoaWxkO1xuICAgIH1cbiAgICBjb25zdCBfQ29ubmVjdCA9IFJlYWN0Lm1lbW8oQ29ubmVjdEZ1bmN0aW9uKTtcbiAgICBjb25zdCBDb25uZWN0ID0gX0Nvbm5lY3Q7XG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gQ29ubmVjdEZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgaWYgKGZvcndhcmRSZWYpIHtcbiAgICAgIGNvbnN0IF9mb3J3YXJkZWQgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbm5lY3QsIHsgLi4ucHJvcHMsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlZiB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGZvcndhcmRlZCA9IF9mb3J3YXJkZWQ7XG4gICAgICBmb3J3YXJkZWQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgIGZvcndhcmRlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaG9pc3ROb25SZWFjdFN0YXRpY3MoZm9yd2FyZGVkLCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbiAgcmV0dXJuIHdyYXBXaXRoQ29ubmVjdDtcbn1cbnZhciBjb25uZWN0X2RlZmF1bHQgPSBjb25uZWN0O1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92aWRlci50c3hcbmZ1bmN0aW9uIFByb3ZpZGVyKHtcbiAgc3RvcmUsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICBzZXJ2ZXJTdGF0ZSxcbiAgc3RhYmlsaXR5Q2hlY2sgPSBcIm9uY2VcIixcbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gXCJvbmNlXCJcbn0pIHtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZTogc2VydmVyU3RhdGUgPyAoKSA9PiBzZXJ2ZXJTdGF0ZSA6IHZvaWQgMCxcbiAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXG4gICAgfTtcbiAgfSwgW3N0b3JlLCBzZXJ2ZXJTdGF0ZSwgc3RhYmlsaXR5Q2hlY2ssIGlkZW50aXR5RnVuY3Rpb25DaGVja10pO1xuICBjb25zdCBwcmV2aW91c1N0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLCBbc3RvcmVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBzdWJzY3JpcHRpb24gfSA9IGNvbnRleHRWYWx1ZTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzO1xuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gc3RvcmUuZ2V0U3RhdGUoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSB2b2lkIDA7XG4gICAgfTtcbiAgfSwgW2NvbnRleHRWYWx1ZSwgcHJldmlvdXNTdGF0ZV0pO1xuICBjb25zdCBDb250ZXh0ID0gY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRWYWx1ZSB9LCBjaGlsZHJlbik7XG59XG52YXIgUHJvdmlkZXJfZGVmYXVsdCA9IFByb3ZpZGVyO1xuXG4vLyBzcmMvaG9va3MvdXNlU3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpXG4gICk7XG4gIGNvbnN0IHVzZVN0b3JlMiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZVN0b3JlMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlU3RvcmUyXG4gIH0pO1xuICByZXR1cm4gdXNlU3RvcmUyO1xufVxudmFyIHVzZVN0b3JlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVN0b3JlSG9vaygpO1xuXG4vLyBzcmMvaG9va3MvdXNlRGlzcGF0Y2gudHNcbmZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlU3RvcmUyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VTdG9yZSA6IGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlRGlzcGF0Y2gyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUyKCk7XG4gICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZURpc3BhdGNoMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlRGlzcGF0Y2gyXG4gIH0pO1xuICByZXR1cm4gdXNlRGlzcGF0Y2gyO1xufVxudmFyIHVzZURpc3BhdGNoID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURpc3BhdGNoSG9vaygpO1xuXG4vLyBzcmMvZXhwb3J0cy50c1xudmFyIGJhdGNoID0gZGVmYXVsdE5vb3BCYXRjaDtcblxuLy8gc3JjL2luZGV4LnRzXG5pbml0aWFsaXplVXNlU2VsZWN0b3IodXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKTtcbmluaXRpYWxpemVDb25uZWN0KFJlYWN0Mi51c2VTeW5jRXh0ZXJuYWxTdG9yZSk7XG5leHBvcnQge1xuICBQcm92aWRlcl9kZWZhdWx0IGFzIFByb3ZpZGVyLFxuICBSZWFjdFJlZHV4Q29udGV4dCxcbiAgYmF0Y2gsXG4gIGNvbm5lY3RfZGVmYXVsdCBhcyBjb25uZWN0LFxuICBjcmVhdGVEaXNwYXRjaEhvb2ssXG4gIGNyZWF0ZVNlbGVjdG9ySG9vayxcbiAgY3JlYXRlU3RvcmVIb29rLFxuICBzaGFsbG93RXF1YWwsXG4gIHVzZURpc3BhdGNoLFxuICB1c2VTZWxlY3RvcixcbiAgdXNlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yZWR1eC5tanMubWFwIl0sIm5hbWVzIjpbIlJlYWN0MiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyIiwiUmVhY3RPcmlnaW5hbCIsIlJlYWN0IiwiQ29udGV4dEtleSIsIlN5bWJvbCIsImZvciIsImdUIiwiZ2xvYmFsVGhpcyIsImdldENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiY29udGV4dE1hcCIsIk1hcCIsInJlYWxDb250ZXh0IiwiZ2V0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIiwic2V0IiwiUmVhY3RSZWR1eENvbnRleHQiLCJub3RJbml0aWFsaXplZCIsIkVycm9yIiwiY3JlYXRlUmVkdXhDb250ZXh0SG9vayIsImNvbnRleHQiLCJ1c2VSZWR1eENvbnRleHQyIiwiY29udGV4dFZhbHVlIiwidXNlQ29udGV4dCIsInVzZVJlZHV4Q29udGV4dCIsImluaXRpYWxpemVVc2VTZWxlY3RvciIsImZuIiwicmVmRXF1YWxpdHkiLCJhIiwiYiIsImNyZWF0ZVNlbGVjdG9ySG9vayIsInVzZVNlbGVjdG9yMiIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbk9yT3B0aW9ucyIsImVxdWFsaXR5Rm4iLCJkZXZNb2RlQ2hlY2tzIiwic3RvcmUiLCJzdWJzY3JpcHRpb24iLCJnZXRTZXJ2ZXJTdGF0ZSIsInN0YWJpbGl0eUNoZWNrIiwiaWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwiZmlyc3RSdW4iLCJ1c2VSZWYiLCJ3cmFwcGVkU2VsZWN0b3IiLCJ1c2VDYWxsYmFjayIsIm5hbWUiLCJzdGF0ZSIsInNlbGVjdGVkIiwiZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2siLCJmaW5hbFN0YWJpbGl0eUNoZWNrIiwiY3VycmVudCIsInRvQ29tcGFyZSIsInN0YWNrIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwic2VsZWN0ZWQyIiwic2VsZWN0ZWRTdGF0ZSIsImFkZE5lc3RlZFN1YiIsImdldFN0YXRlIiwidXNlRGVidWdWYWx1ZSIsIk9iamVjdCIsImFzc2lnbiIsIndpdGhUeXBlcyIsInVzZVNlbGVjdG9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiRm9yd2FyZFJlZiIsIk1lbW8iLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInR5cGVPZiIsIm9iamVjdCIsIiQkdHlwZW9mVHlwZSIsImlzQ29udGV4dENvbnN1bWVyIiwiaXNNZW1vIiwid2FybmluZyIsIm1lc3NhZ2UiLCJlcnJvciIsInZlcmlmeSIsIm1ldGhvZE5hbWUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2ZXJpZnlTdWJzZWxlY3RvcnMiLCJtYXBTdGF0ZVRvUHJvcHMiLCJtYXBEaXNwYXRjaFRvUHJvcHMiLCJtZXJnZVByb3BzIiwicHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkiLCJkaXNwYXRjaCIsImFyZVN0YXRlc0VxdWFsIiwiYXJlT3duUHJvcHNFcXVhbCIsImFyZVN0YXRlUHJvcHNFcXVhbCIsImhhc1J1bkF0TGVhc3RPbmNlIiwib3duUHJvcHMiLCJzdGF0ZVByb3BzIiwiZGlzcGF0Y2hQcm9wcyIsIm1lcmdlZFByb3BzIiwiaGFuZGxlRmlyc3RDYWxsIiwiZmlyc3RTdGF0ZSIsImZpcnN0T3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlIiwiZGVwZW5kc09uT3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wcyIsImhhbmRsZU5ld1N0YXRlIiwibmV4dFN0YXRlUHJvcHMiLCJzdGF0ZVByb3BzQ2hhbmdlZCIsImhhbmRsZVN1YnNlcXVlbnRDYWxscyIsIm5leHRTdGF0ZSIsIm5leHRPd25Qcm9wcyIsInByb3BzQ2hhbmdlZCIsInN0YXRlQ2hhbmdlZCIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3IiLCJmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiaW5pdE1hcFN0YXRlVG9Qcm9wcyIsImluaXRNYXBEaXNwYXRjaFRvUHJvcHMiLCJpbml0TWVyZ2VQcm9wcyIsIm9wdGlvbnMiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJrZXkiLCJhY3Rpb25DcmVhdG9yIiwiYXJncyIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidmVyaWZ5UGxhaW5PYmplY3QiLCJ2YWx1ZSIsIndyYXBNYXBUb1Byb3BzQ29uc3RhbnQiLCJnZXRDb25zdGFudCIsImluaXRDb25zdGFudFNlbGVjdG9yIiwiY29uc3RhbnQiLCJjb25zdGFudFNlbGVjdG9yIiwiZ2V0RGVwZW5kc09uT3duUHJvcHMiLCJtYXBUb1Byb3BzIiwiQm9vbGVhbiIsImxlbmd0aCIsIndyYXBNYXBUb1Byb3BzRnVuYyIsImluaXRQcm94eVNlbGVjdG9yIiwicHJveHkiLCJtYXBUb1Byb3BzUHJveHkiLCJzdGF0ZU9yRGlzcGF0Y2giLCJkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IiwicHJvcHMiLCJjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSIsImFyZyIsIndyYXBwZWRDb21wb25lbnROYW1lIiwibWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeSIsIm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkiLCJkZWZhdWx0TWVyZ2VQcm9wcyIsIndyYXBNZXJnZVByb3BzRnVuYyIsImluaXRNZXJnZVByb3BzUHJveHkiLCJhcmVNZXJnZWRQcm9wc0VxdWFsIiwiaGFzUnVuT25jZSIsIm1lcmdlUHJvcHNQcm94eSIsIm5leHRNZXJnZWRQcm9wcyIsIm1lcmdlUHJvcHNGYWN0b3J5IiwiZGVmYXVsdE5vb3BCYXRjaCIsImNhbGxiYWNrIiwiY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uIiwiZmlyc3QiLCJsYXN0IiwiY2xlYXIiLCJub3RpZnkiLCJsaXN0ZW5lciIsIm5leHQiLCJsaXN0ZW5lcnMiLCJwdXNoIiwic3Vic2NyaWJlIiwiaXNTdWJzY3JpYmVkIiwicHJldiIsInVuc3Vic2NyaWJlIiwibnVsbExpc3RlbmVycyIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsInBhcmVudFN1YiIsInN1YnNjcmlwdGlvbnNBbW91bnQiLCJzZWxmU3Vic2NyaWJlZCIsInRyeVN1YnNjcmliZSIsImNsZWFudXBMaXN0ZW5lciIsInJlbW92ZWQiLCJ0cnlVbnN1YnNjcmliZSIsIm5vdGlmeU5lc3RlZFN1YnMiLCJoYW5kbGVDaGFuZ2VXcmFwcGVyIiwib25TdGF0ZUNoYW5nZSIsInRyeVN1YnNjcmliZVNlbGYiLCJ0cnlVbnN1YnNjcmliZVNlbGYiLCJnZXRMaXN0ZW5lcnMiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpc1JlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwicHJvZHVjdCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJpcyIsIngiLCJ5Iiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXMiLCJrZXlzQiIsImkiLCJSRUFDVF9TVEFUSUNTIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJjb250ZXh0VHlwZSIsImNvbnRleHRUeXBlcyIsImRlZmF1bHRQcm9wcyIsImdldERlZmF1bHRQcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm1peGlucyIsInByb3BUeXBlcyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJjYWxsZWUiLCJhcmd1bWVudHMiLCJhcml0eSIsIkZPUldBUkRfUkVGX1NUQVRJQ1MiLCJyZW5kZXIiLCJNRU1PX1NUQVRJQ1MiLCJjb21wYXJlIiwiVFlQRV9TVEFUSUNTIiwiZ2V0U3RhdGljcyIsImNvbXBvbmVudCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm9iamVjdFByb3RvdHlwZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiaW5oZXJpdGVkQ29tcG9uZW50IiwiY29uY2F0IiwidGFyZ2V0U3RhdGljcyIsInNvdXJjZVN0YXRpY3MiLCJkZXNjcmlwdG9yIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJpbml0aWFsaXplQ29ubmVjdCIsIk5PX1NVQlNDUklQVElPTl9BUlJBWSIsInN0cmluZ2lmeUNvbXBvbmVudCIsIkNvbXAiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyIiwiU3RyaW5nIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzIiwiZWZmZWN0RnVuYyIsImVmZmVjdEFyZ3MiLCJkZXBlbmRlbmNpZXMiLCJjYXB0dXJlV3JhcHBlclByb3BzIiwibGFzdFdyYXBwZXJQcm9wcyIsImxhc3RDaGlsZFByb3BzIiwicmVuZGVySXNTY2hlZHVsZWQiLCJ3cmFwcGVyUHJvcHMiLCJjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlIiwic3Vic2NyaWJlVXBkYXRlcyIsInNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyIsImNoaWxkUHJvcHNTZWxlY3RvciIsImlzTW91bnRlZCIsImFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lciIsImRpZFVuc3Vic2NyaWJlIiwibGFzdFRocm93bkVycm9yIiwiY2hlY2tGb3JVcGRhdGVzIiwibGF0ZXN0U3RvcmVTdGF0ZSIsIm5ld0NoaWxkUHJvcHMiLCJ1bnN1YnNjcmliZVdyYXBwZXIiLCJzdHJpY3RFcXVhbCIsImhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24iLCJjb25uZWN0IiwicHVyZSIsImZvcndhcmRSZWYiLCJDb250ZXh0Iiwid3JhcFdpdGhDb25uZWN0IiwiV3JhcHBlZENvbXBvbmVudCIsImlzVmFsaWQiLCJzZWxlY3RvckZhY3RvcnlPcHRpb25zIiwiQ29ubmVjdEZ1bmN0aW9uIiwicHJvcHNDb250ZXh0IiwicmVhY3RSZWR1eEZvcndhcmRlZFJlZiIsInVzZU1lbW8iLCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiIsIndyYXBwZXJQcm9wczIiLCJDb250ZXh0VG9Vc2UiLCJSZXN1bHRDb250ZXh0IiwiQ29uc3VtZXIiLCJkaWRTdG9yZUNvbWVGcm9tUHJvcHMiLCJkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCIsInN1YnNjcmlwdGlvbjIiLCJub3RpZnlOZXN0ZWRTdWJzMiIsImJpbmQiLCJvdmVycmlkZGVuQ29udGV4dFZhbHVlIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciIsInN1YnNjcmliZUZvclJlYWN0IiwicmVhY3RMaXN0ZW5lciIsImFjdHVhbENoaWxkUHJvcHMiLCJyZW5kZXJlZFdyYXBwZWRDb21wb25lbnQiLCJyZWYiLCJyZW5kZXJlZENoaWxkIiwiUHJvdmlkZXIiLCJfQ29ubmVjdCIsIm1lbW8iLCJDb25uZWN0IiwiX2ZvcndhcmRlZCIsImZvcndhcmRDb25uZWN0UmVmIiwiZm9yd2FyZGVkIiwiY29ubmVjdF9kZWZhdWx0IiwiY2hpbGRyZW4iLCJzZXJ2ZXJTdGF0ZSIsInByZXZpb3VzU3RhdGUiLCJQcm92aWRlcl9kZWZhdWx0IiwiY3JlYXRlU3RvcmVIb29rIiwidXNlU3RvcmUyIiwidXNlU3RvcmUiLCJjcmVhdGVEaXNwYXRjaEhvb2siLCJ1c2VEaXNwYXRjaDIiLCJ1c2VEaXNwYXRjaCIsImJhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-redux/dist/react-redux.mjs\n");

/***/ })

};
;